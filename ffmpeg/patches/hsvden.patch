diff -ruN ffmpeg-orig/configure ffmpeg/configure
--- ffmpeg-orig/configure	2020-05-27 19:20:05.000000000 +0300
+++ ffmpeg/configure	2020-05-31 08:40:48.813985000 +0300
@@ -304,7 +304,6 @@
   --enable-mbedtls         enable mbedTLS, needed for https support
                            if openssl, gnutls or libtls is not used [no]
   --enable-mediacodec      enable Android MediaCodec support [no]
-  --enable-mediafoundation enable encoding via MediaFoundation [auto]
   --enable-libmysofa       enable libmysofa, needed for sofalizer filter [no]
   --enable-openal          enable OpenAL 1.1 capture support [no]
   --enable-opencl          enable OpenCL processing [no]
@@ -1705,7 +1704,6 @@
     libxcb_shape
     libxcb_xfixes
     lzma
-    mediafoundation
     schannel
     sdl2
     securetransport
@@ -2352,6 +2350,7 @@
     cbs_vp9
     dirac_parse
     dnn
+    hsv
     dvprofile
     exif
     faandct
@@ -2799,7 +2798,6 @@
 mxpeg_decoder_select="mjpeg_decoder"
 nellymoser_decoder_select="mdct sinewin"
 nellymoser_encoder_select="audio_frame_queue mdct sinewin"
-notchlc_decoder_select="lzf"
 nuv_decoder_select="idctdsp lzo"
 on2avc_decoder_select="mdct"
 opus_decoder_deps="swresample"
@@ -3014,8 +3012,6 @@
 wmv3_vdpau_hwaccel_select="vc1_vdpau_hwaccel"
 
 # hardware-accelerated codecs
-mediafoundation_deps="mftransform_h MFCreateAlignedMemoryBuffer"
-mediafoundation_extralibs="-lmfplat -lmfuuid -lole32 -lstrmiids"
 omx_deps="libdl pthreads"
 omx_rpi_select="omx"
 qsv_deps="libmfx"
@@ -3040,8 +3036,6 @@
 nvenc_deps_any="libdl LoadLibrary"
 nvenc_encoder_deps="nvenc"
 
-aac_mf_encoder_deps="mediafoundation"
-ac3_mf_encoder_deps="mediafoundation"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
 h264_amf_encoder_deps="amf"
@@ -3050,7 +3044,6 @@
 h264_cuvid_decoder_select="h264_mp4toannexb_bsf"
 h264_mediacodec_decoder_deps="mediacodec"
 h264_mediacodec_decoder_select="h264_mp4toannexb_bsf h264_parser"
-h264_mf_encoder_deps="mediafoundation"
 h264_mmal_decoder_deps="mmal"
 h264_nvenc_encoder_deps="nvenc"
 h264_omx_encoder_deps="omx"
@@ -3067,7 +3060,6 @@
 hevc_cuvid_decoder_select="hevc_mp4toannexb_bsf"
 hevc_mediacodec_decoder_deps="mediacodec"
 hevc_mediacodec_decoder_select="hevc_mp4toannexb_bsf hevc_parser"
-hevc_mf_encoder_deps="mediafoundation"
 hevc_nvenc_encoder_deps="nvenc"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
@@ -3084,7 +3076,6 @@
 mjpeg_qsv_encoder_select="qsvenc"
 mjpeg_vaapi_encoder_deps="VAEncPictureParameterBufferJPEG"
 mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
-mp3_mf_encoder_deps="mediafoundation"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
 mpeg2_crystalhd_decoder_select="crystalhd"
@@ -3517,6 +3508,7 @@
 dilation_opencl_filter_deps="opencl"
 dnn_processing_filter_deps="swscale"
 dnn_processing_filter_select="dnn"
+hsvden_filter_select="hsv"
 drawtext_filter_deps="libfreetype"
 drawtext_filter_suggest="libfontconfig libfribidi"
 elbg_filter_deps="avcodec"
@@ -6111,7 +6103,6 @@
 check_headers linux/perf_event.h
 check_headers libcrystalhd/libcrystalhd_if.h
 check_headers malloc.h
-check_headers mftransform.h
 check_headers net/udplite.h
 check_headers poll.h
 check_headers sys/param.h
@@ -6174,7 +6165,6 @@
 check_type "windows.h d3d11.h" "ID3D11VideoDecoder"
 check_type "windows.h d3d11.h" "ID3D11VideoContext"
 check_type "d3d9.h dxva2api.h" DXVA2_ConfigPictureDecode -D_WIN32_WINNT=0x0602
-check_func_headers mfapi.h MFCreateAlignedMemoryBuffer -lmfplat
 
 check_type "vdpau/vdpau.h" "VdpPictureInfoHEVC"
 check_type "vdpau/vdpau.h" "VdpPictureInfoVP9"
diff -ruN ffmpeg-orig/libavfilter/af_hsvden.c ffmpeg/libavfilter/af_hsvden.c
--- ffmpeg-orig/libavfilter/af_hsvden.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/af_hsvden.c	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,314 @@
+/*
+ * Copyright (c) 2020 Mikhail Masyagin
+ *
+ * This file is NOT part of FFmpeg.
+ */
+#include "libavutil/opt.h"
+#include "avfilter.h"
+#include "audio.h"
+
+#include "hsv_interface.h"
+
+struct HSV_DEN
+{
+	const AVClass*class;
+
+	char*mode;
+
+	struct HSV_CONFIG conf;
+	hsvc_t hsvc;
+};
+
+typedef struct HSV_DEN HSV_DEN;
+
+#define OFFSET(x) offsetof(HSV_DEN, x)
+#define A AV_OPT_FLAG_AUDIO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
+
+static const AVOption hsvden_options[] =
+{
+	{
+	 .name = "mode",
+	 .help = "Noise suppression mode: \"specsub\"|\"wiener\"|\"tsnr\"|\"tsnrg\"|\"rtsnr\"|\"rtsnrg\".",
+	 .offset = OFFSET(mode),
+	 .type = AV_OPT_TYPE_STRING,
+	 .default_val = { .str = "tsnr" },
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+	{
+	 .name = "m",
+	 .help = "Noise suppression mode: \"specsub\"|\"wiener\"|\"tsnr\"|\"tsnrg\"|\"rtsnr\"|\"rtsnrg\".",
+	 .offset = OFFSET(mode),
+	 .type = AV_OPT_TYPE_STRING,
+	 .default_val = { .str = "tsnr" },
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+
+	{
+	 .name = "frame",
+	 .help = "Frame size in samples.",
+	 .offset = OFFSET(conf.frame_size_smpls),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+	{
+	 .name = "f",
+	 .help = "Frame size in samples.",
+	 .offset = OFFSET(conf.frame_size_smpls),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+
+	{
+	 .name = "overlap",
+	 .help = "Overlap in percents.",
+	 .offset = OFFSET(conf.overlap_perc),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 100,
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+	{
+	 .name = "o",
+	 .help = "Overlap in percents.",
+	 .offset = OFFSET(conf.overlap_perc),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 100,
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+
+	{
+	 .name = "dft",
+	 .help = "DFT size in samples.",
+	 .offset = OFFSET(conf.dft_size_smpls),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+	{
+	 .name = "d",
+	 .help = "DFT size in samples.",
+	 .offset = OFFSET(conf.dft_size_smpls),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+
+	{
+	 .name = "cap",
+	 .help = "Internal buffer capacity in bytes",
+	 .offset = OFFSET(conf.cap),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+	{
+	 .name = "c",
+	 .help = "Internal buffer capacity in bytes",
+	 .offset = OFFSET(conf.cap),
+	 .type = AV_OPT_TYPE_INT,
+	 .default_val = { .i64 = 0 },
+	 .min = 0,
+	 .max = 1048576, /* 2^20 */
+	 .flags = (AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM),
+	},
+
+	{ NULL },
+};
+
+AVFILTER_DEFINE_CLASS(hsvden);
+
+static av_cold int init(AVFilterContext*ctx)
+{
+	HSV_DEN*s = ctx->priv;
+
+	memset(&s->conf, 0, sizeof(s->conf));
+
+	return 0;
+}
+
+static av_cold void uninit(AVFilterContext*ctx)
+{
+	HSV_DEN*s = ctx->priv;
+	if (s->hsvc != NULL) {
+		hsvc_deconfig(s->hsvc);
+		hsvc_free(s->hsvc);
+	}
+}
+
+static const enum AVSampleFormat sample_fmts[] =
+{
+	AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE,
+};
+
+static int query_formats(AVFilterContext*ctx)
+{
+	int r;
+	
+	AVFilterChannelLayouts*layouts;
+	AVFilterFormats*formats;
+
+	layouts = ff_all_channel_counts();
+	if (layouts == NULL) {
+		return AVERROR(ENOMEM);
+	}
+
+	r = ff_set_common_channel_layouts(ctx, layouts);
+	if (r < 0) {
+		return r;
+	}
+
+	formats = ff_make_format_list(sample_fmts);
+	if (formats == NULL) {
+		return AVERROR(ENOMEM);
+	}
+
+	r = ff_set_common_formats(ctx, formats);
+	if (r < 0) {
+		return r;
+	}
+
+	formats = ff_all_samplerates();
+	if (formats == NULL) {
+		return AVERROR(ENOMEM);
+	}
+
+	return ff_set_common_samplerates(ctx, formats);
+}
+
+static int config_props(AVFilterLink*inlink)
+{
+	int r;
+
+	enum HSV_CODE hsv_r;
+
+	AVFilterContext*ctx = inlink->dst;
+	HSV_DEN*s = ctx->priv;
+
+	s->conf.sr = inlink->sample_rate;
+	s->conf.ch = inlink->channels;
+	s->conf.bs = 16;
+
+	if (strcmp(s->mode, "specsub") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_SPECSUB;
+	} else if (strcmp(s->mode, "wiener") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_WIENER;
+	} else if (strcmp(s->mode, "tsnr") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_TSNR;
+	} else if (strcmp(s->mode, "tsnrg") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_TSNR_G;
+	} else if (strcmp(s->mode, "rtsnr") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_RTSNR;
+	} else if (strcmp(s->mode, "rtsnrg") == 0) {
+		s->conf.mode = HSV_SUPPRESSOR_MODE_RTSNR_G;
+	} else {
+		av_log(ctx, AV_LOG_ERROR, "Invalid mode (%s)\n", s->mode);
+		return AVERROR(EINVAL);
+	}
+
+	r = hsvc_validate_config(&(s->conf));
+	if ((enum HSV_CODE) r != HSV_CODE_OK) {
+		av_log(ctx, AV_LOG_ERROR, "Invalid configuration in parameter (%d)\n", r);
+		return AVERROR(EINVAL);
+	}
+
+	s->hsvc = create_hsvc();
+	if (s->hsvc == NULL) {
+		av_log(ctx, AV_LOG_ERROR, "Unable to create \"hsv\" context!\n");
+		return AVERROR(ENOMEM);
+	}
+
+	hsv_r = hsvc_config(s->hsvc, &(s->conf));
+	if (hsv_r != HSV_CODE_OK) {
+		hsvc_free(s->hsvc);
+		s->hsvc = NULL;
+		av_log(ctx, AV_LOG_ERROR, "Unable to allocate \"hsv\" context internal buffers!\n");
+		return AVERROR(ENOMEM);
+	}
+
+	return 0;
+}
+
+static int filter_frame(AVFilterLink*inlink, AVFrame*frame)
+{
+	int processed;
+	
+	AVFilterContext*ctx = inlink->dst;
+	HSV_DEN*s = ctx->priv;
+	AVFrame*out_frame;
+
+	if (s->hsvc == NULL) {
+		out_frame = frame;
+		return ff_filter_frame(ctx->outputs[0], out_frame);
+	}
+
+	out_frame = ff_get_audio_buffer(ctx->outputs[0], frame->nb_samples * 2);
+	if (out_frame == NULL) {
+		av_frame_free(&frame);
+		return AVERROR(ENOMEM);
+	}
+	av_frame_copy_props(out_frame, frame);
+
+	processed = hsvc_push(s->hsvc, (char*) frame->extended_data[0], (frame->nb_samples * 2) * frame->channels);
+	if (processed < 0) {
+		av_log(ctx, AV_LOG_ERROR, "\"hsv\" context overflow error!\n");
+		return AVERROR(EINVAL);
+	} else if (processed == 0) {
+		out_frame->nb_samples = 0;
+	} else if (processed > 0) {
+		out_frame->nb_samples = hsvc_get(s->hsvc, (char*) out_frame->extended_data[0], (out_frame->nb_samples * 2) * frame->channels) / 2;
+		out_frame->nb_samples /= frame->channels;
+	}
+
+	av_frame_free(&frame);
+
+	return ff_filter_frame(ctx->outputs[0], out_frame);
+}
+
+static const AVFilterPad hsvden_inputs[] =
+{
+	{
+		.name = "default",
+		.type = AVMEDIA_TYPE_AUDIO,
+		.config_props = config_props,
+		.filter_frame = filter_frame,
+	},
+
+	{ NULL },
+};
+
+static const AVFilterPad hsvden_outputs[] =
+{
+	{
+		.name = "default",
+		.type = AVMEDIA_TYPE_AUDIO,
+	},
+
+	{ NULL },
+};
+
+AVFilter ff_af_hsvden = {
+	.name		   = "hsvden",
+	.description   = NULL_IF_CONFIG_SMALL("Denoise speech using \"HSV\" library."),
+	.query_formats = query_formats,
+	.priv_size	   = sizeof(HSV_DEN),
+	.priv_class	   = &hsvden_class,
+	.init		   = init,
+	.uninit		   = uninit,
+	.inputs		   = hsvden_inputs,
+	.outputs	   = hsvden_outputs,
+};
diff -ruN ffmpeg-orig/libavfilter/allfilters.c ffmpeg/libavfilter/allfilters.c
--- ffmpeg-orig/libavfilter/allfilters.c	2020-05-23 19:20:02.000000000 +0300
+++ ffmpeg/libavfilter/allfilters.c	2020-05-31 08:40:48.813985000 +0300
@@ -23,6 +23,13 @@
 #include "avfilter.h"
 #include "config.h"
 
+/*
+ * Additional filters:
+ * "HSV" speech denoise filter.
+ */
+
+extern AVFilter ff_af_hsvden;
+
 extern AVFilter ff_af_abench;
 extern AVFilter ff_af_acompressor;
 extern AVFilter ff_af_acontrast;
@@ -415,7 +422,6 @@
 extern AVFilter ff_vf_unpremultiply;
 extern AVFilter ff_vf_unsharp;
 extern AVFilter ff_vf_unsharp_opencl;
-extern AVFilter ff_vf_untile;
 extern AVFilter ff_vf_uspp;
 extern AVFilter ff_vf_v360;
 extern AVFilter ff_vf_vaguedenoiser;
@@ -450,7 +456,6 @@
 extern AVFilter ff_vsrc_color;
 extern AVFilter ff_vsrc_coreimagesrc;
 extern AVFilter ff_vsrc_frei0r_src;
-extern AVFilter ff_vsrc_gradients;
 extern AVFilter ff_vsrc_haldclutsrc;
 extern AVFilter ff_vsrc_life;
 extern AVFilter ff_vsrc_mandelbrot;
diff -ruN ffmpeg-orig/libavfilter/hsv/dft/dft.c ffmpeg/libavfilter/hsv/dft/dft.c
--- ffmpeg-orig/libavfilter/hsv/dft/dft.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/dft/dft.c	2020-05-31 09:08:43.070671000 +0300
@@ -0,0 +1,438 @@
+/**
+ * \file dft.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API алгоритма дискретного преобразования Фурье.
+ */
+/**
+ * \ingroup dft
+ * \{
+ */
+#include "dft.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+dft_t create_dft()
+{
+	dft_t dft;
+
+	dft = (dft_t) calloc(1, sizeof(struct DISCRETE_FOURIER_TRANSFORM));
+	return dft;
+}
+
+static int is_pow_2(unsigned n);
+static unsigned next_pow_2(unsigned n);
+static void dft_inner(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n);
+
+static enum DFT_CODE config_cooley_tukey(struct COOLEY_TUKEY*ct, unsigned dft_size)
+{
+	enum DFT_CODE r;
+
+	unsigned i;
+
+	if (is_pow_2(dft_size)) {
+		ct->tab_size = dft_size / 2;
+	} else {
+		ct->tab_size = next_pow_2(dft_size) / 2;
+	}
+	ct->sin_tab = (hsv_numeric_t*) calloc(ct->tab_size, sizeof(hsv_numeric_t));
+	if (ct->sin_tab == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err0;
+	}
+	ct->cos_tab = (hsv_numeric_t*) calloc(ct->tab_size, sizeof(hsv_numeric_t));
+	if (ct->cos_tab == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err1;
+	}
+
+	ct->tab_size *= 2;
+	for (i = 0; i < ct->tab_size / 2; i++) {
+		ct->cos_tab[i] = HSV_COS(2 * M_PI * i / ct->tab_size);
+		ct->sin_tab[i] = HSV_SIN(2 * M_PI * i / ct->tab_size);
+	}
+	ct->tab_size /= 2;
+	
+	ct->initialized = 1;
+
+	return DFT_CODE_OK;
+
+ err1:
+	free(ct->sin_tab);
+ err0:
+	return r;
+}
+
+static void deconfig_cooley_tukey(struct COOLEY_TUKEY*ct)
+{
+	if (! ct->initialized) {
+		return;
+	}
+
+	free(ct->cos_tab);
+	free(ct->sin_tab);
+}
+
+static enum DFT_CODE config_bluestein(struct BLUESTEIN*bl, unsigned dft_size)
+{
+	enum DFT_CODE r;
+	
+	unsigned i;
+
+	if (is_pow_2(dft_size)) {
+		return DFT_CODE_OK;
+	}
+
+	bl->tab_size = dft_size;
+	bl->sin_tab = (hsv_numeric_t*) calloc(dft_size, sizeof(hsv_numeric_t));
+	if (bl->sin_tab == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err0;
+	}
+	bl->cos_tab = (hsv_numeric_t*) calloc(dft_size, sizeof(hsv_numeric_t));
+	if (bl->cos_tab == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	bl->nb = next_pow_2(dft_size);
+	bl->a_real = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->a_real == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err2;
+	}
+	bl->a_imag = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->a_imag == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err3;
+	}
+	bl->b_real = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->b_real == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err4;
+	}
+	bl->b_imag = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->b_imag == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err5;
+	}
+	bl->c_real = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->c_real == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err6;
+	}
+	bl->c_imag = (hsv_numeric_t*) calloc(sizeof(hsv_numeric_t), bl->nb);
+	if (bl->c_imag == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err7;
+	}
+
+	for (i = 0; i < bl->tab_size; i++) {
+		unsigned tmp = ((unsigned)i * i) % ((unsigned) bl->tab_size * 2);
+		hsv_numeric_t angle = M_PI * tmp / bl->tab_size;
+		bl->cos_tab[i] = HSV_COS(angle);
+		bl->sin_tab[i] = HSV_SIN(angle);
+	}
+
+	/* Вычисляется лишь один раз на старте. */
+	bl->b_real[0] = bl->cos_tab[0];
+	bl->b_imag[0] = bl->sin_tab[0];
+	for (i = 1; i < bl->tab_size; i++) {
+		bl->b_real[i] = bl->b_real[bl->nb - i] = bl->cos_tab[i];
+		bl->b_imag[i] = bl->b_imag[bl->nb - i] = bl->sin_tab[i];
+	}
+
+	bl->initialized = 1;
+
+	return DFT_CODE_OK;
+
+ err7:
+	free(bl->c_real);
+ err6:
+	free(bl->b_imag);
+ err5:
+	free(bl->b_real);
+ err4:
+	free(bl->a_imag);
+ err3:
+	free(bl->a_real);
+ err2:
+	free(bl->cos_tab);
+ err1:
+	free(bl->sin_tab);
+ err0:
+	return r;
+}
+
+static void deconfig_bluestein(struct BLUESTEIN*bl)
+{
+	if (! bl->initialized) {
+		return;
+	}
+
+	free(bl->c_imag);
+	free(bl->c_real);
+	free(bl->b_imag);
+	free(bl->b_real);
+	free(bl->a_imag);
+	free(bl->a_real);
+	free(bl->cos_tab);
+	free(bl->sin_tab);
+}
+
+enum DFT_CODE dft_config(dft_t dft, unsigned dft_size)
+{
+	enum DFT_CODE r;
+
+	dft->dft_size = dft_size;
+	dft->real = (hsv_numeric_t*) calloc(dft_size, sizeof(hsv_numeric_t));
+	if (dft->real == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err0;
+	}
+	dft->imag = (hsv_numeric_t*) calloc(dft_size, sizeof(hsv_numeric_t));
+	if (dft->imag == NULL) {
+		r = DFT_CODE_ALLOC_ERR;
+		goto err1;
+	}
+
+	r = config_cooley_tukey(&(dft->ct), dft_size);
+	if (r != DFT_CODE_OK) {
+		goto err2;
+	}
+
+	r = config_bluestein(&(dft->bl), dft_size);
+	if (r != DFT_CODE_OK) {
+		goto err3;
+	}
+	/* Вычисляется лишь один раз на старте. */
+	dft_inner(dft, dft->bl.b_real, dft->bl.b_imag, dft->bl.nb);
+
+	return DFT_CODE_OK;
+
+ err3:
+	deconfig_cooley_tukey(&(dft->ct));
+ err2:
+	free(dft->imag);
+ err1:
+	free(dft->real);
+ err0:
+	return r;
+}
+
+static void cooley_tukey(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n);
+static void bluestein(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n);
+
+static void dft_inner(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n)
+{
+	if (n == 0) {
+		return;
+	} else if (is_pow_2(n)) {
+		cooley_tukey(dft, real, imag, n);
+	} else {
+		bluestein(dft, real, imag, n);
+	}
+}
+
+static unsigned inverse(unsigned val, int w)
+{
+	int i;
+
+	unsigned res = 0;
+
+	for (i = 0; i < w; i++, val >>= 1) {
+		res = (res << 1) | (val & 1U);
+	}
+	return res;
+}
+
+static void swap_complex(hsv_numeric_t*real_a, hsv_numeric_t*imag_a, hsv_numeric_t*real_b, hsv_numeric_t*imag_b)
+{
+	hsv_numeric_t tmp;
+
+	tmp = *real_a;
+	*real_a = *real_b;
+	*real_b = tmp;
+
+	tmp = *imag_a;
+	*imag_a = *imag_b;
+	*imag_b = tmp;
+}
+
+static void cooley_tukey(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n)
+{
+	unsigned i, j, k;
+
+	unsigned n2;
+	
+	int lvls = 0;
+	for (i = n; i > ((unsigned) 1); i >>= 1) {
+		lvls++;
+	}
+
+	for (i = 0; i < n; i++) {
+		j = inverse(i, lvls);
+		if (j > i) {
+			swap_complex(real + i, imag + i, real + j, imag + j);
+		}
+	}
+
+	for (n2 = 2; n2 <= n; n2 *= 2) {
+		unsigned half = n2 / 2;
+		unsigned tab_step = n / n2;
+
+		for (i = 0; i < n; i += n2) {
+			for (j = i, k = 0; j < i + half; j++, k += tab_step) {
+				unsigned ind = j + half;
+				hsv_numeric_t tmp_real = real[ind] * dft->ct.cos_tab[k] +
+					imag[ind] * dft->ct.sin_tab[k];
+				hsv_numeric_t tmp_imag = -real[ind] * dft->ct.sin_tab[k] +
+					imag[ind] * dft->ct.cos_tab[k];
+
+				real[ind] = real[j] - tmp_real;
+				imag[ind] = imag[j] - tmp_imag;
+
+				real[j] += tmp_real;
+				imag[j] += tmp_imag;
+			}
+		}
+
+		if (n2 == n) {
+			return;
+		}
+	}
+}
+
+static void convolve(
+		dft_t dft,
+		hsv_numeric_t*a_real, hsv_numeric_t*a_imag,
+		hsv_numeric_t*b_real, hsv_numeric_t*b_imag,
+		hsv_numeric_t*c_real, hsv_numeric_t*c_imag, unsigned n);
+
+static void bluestein(dft_t dft, hsv_numeric_t*real, hsv_numeric_t*imag, unsigned n)
+{
+	unsigned i;
+	unsigned m = next_pow_2(n);
+
+	memset(dft->bl.a_real, '\0', dft->bl.nb * sizeof(hsv_numeric_t));
+	memset(dft->bl.a_imag, '\0', dft->bl.nb * sizeof(hsv_numeric_t));
+
+	for (i = 0; i < n; i++) {
+		dft->bl.a_real[i] =	real[i] * dft->bl.cos_tab[i] +
+			imag[i] * dft->bl.sin_tab[i];
+		dft->bl.a_imag[i] = -real[i] * dft->bl.sin_tab[i] +
+			imag[i] * dft->bl.cos_tab[i];
+	}
+
+	/*
+	// Вычисляется лишь один раз на старте в строках 138-144.
+	memset(dft->bl.b_real, '\0', dft->bl.nb * sizeof(hsv_numeric_t));
+	memset(dft->bl.b_imag, '\0', dft->bl.nb * sizeof(hsv_numeric_t));
+	
+	dft->bl.b_real[0] = dft->bl.cos_tab[0];
+	dft->bl.b_imag[0] = dft->bl.sin_tab[0];
+	for (i = 1; i < n; i++) {
+	  	dft->bl.b_real[i] = dft->bl.b_real[m - i] = dft->bl.cos_tab[i];
+		dft->bl.b_imag[i] = dft->bl.b_imag[m - i] = dft->bl.sin_tab[i];
+	}
+	*/
+	
+	convolve(dft,
+			 dft->bl.a_real, dft->bl.a_imag,
+			 dft->bl.b_real, dft->bl.b_imag,
+			 dft->bl.c_real, dft->bl.c_imag, m);
+	
+	for (i = 0; i < n; i++) {
+		real[i] =  dft->bl.c_real[i] * dft->bl.cos_tab[i] +
+			dft->bl.c_imag[i] * dft->bl.sin_tab[i];
+		imag[i] = -dft->bl.c_real[i] * dft->bl.sin_tab[i] +
+			dft->bl.c_imag[i] * dft->bl.cos_tab[i];
+	}
+}
+
+static void convolve(
+		dft_t dft,
+		hsv_numeric_t*a_real, hsv_numeric_t*a_imag,
+		hsv_numeric_t*b_real, hsv_numeric_t*b_imag,
+		hsv_numeric_t*c_real, hsv_numeric_t*c_imag, unsigned n)
+{
+	unsigned i;
+
+	dft_inner(dft, a_real, a_imag, n);
+	/*
+	// Вычисляется лишь один раз на старте в строках 209-210
+	dft_inner(dft, b_real, b_imag, n);
+	*/
+	
+	for (i = 0; i < n; i++) {
+		hsv_numeric_t tmp = a_real[i] * b_real[i] -
+			a_imag[i] * b_imag[i];
+		a_imag[i] = a_imag[i] * b_real[i] +
+			a_real[i] * b_imag[i];
+		a_real[i] = tmp;
+	}
+
+	/* Обратное быстрое преобразование Фурье. */
+	dft_inner(dft, a_imag, a_real, n);
+	
+	for (i = 0; i < n; i++) {
+		c_real[i] = a_real[i] / n;
+		c_imag[i] = a_imag[i] / n;
+	}
+}
+
+static int is_pow_2(unsigned n)
+{
+	return ((n & (n - 1)) == 0);
+}
+
+static unsigned next_pow_2(unsigned n)
+{
+	unsigned i = 1;
+
+	while ((i / 2) <= n) {
+		i *= 2;
+	}
+	return i;
+}
+
+void dft_run_dft(dft_t dft)
+{
+	dft_inner(dft, dft->real, dft->imag, dft->dft_size);
+}
+
+void dft_run_i_dft(dft_t dft)
+{
+	unsigned i;
+
+	dft_inner(dft, dft->imag, dft->real, dft->dft_size);
+
+	for (i = 0; i < dft->dft_size; i++) {
+		dft->real[i] = dft->real[i] / ((hsv_numeric_t) dft->dft_size);
+		dft->imag[i] = dft->imag[i] / ((hsv_numeric_t) dft->dft_size);
+	}
+}
+
+void dft_deconfig(dft_t dft)
+{
+	deconfig_bluestein(&(dft->bl));
+
+	deconfig_cooley_tukey(&(dft->ct));
+
+	free(dft->imag);
+	free(dft->real);
+}
+
+void dft_clean(dft_t dft)
+{
+	memset(dft, '\0', sizeof(*dft));
+}
+
+void dft_free(dft_t dft)
+{
+	free(dft);
+}
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/dft/dft.h ffmpeg/libavfilter/hsv/dft/dft.h
--- ffmpeg-orig/libavfilter/hsv/dft/dft.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/dft/dft.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,129 @@
+/**
+ * \file dft.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief API алгоритма дискретного преобразования Фурье.
+ */
+/**
+ * \defgroup dft Модуль дискретного преобразования Фурье.
+ * \{
+ */
+#ifndef AVFILTER_HSV_DFT_DFT_H
+#define AVFILTER_HSV_DFT_DFT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_types/hsv_types.h"
+
+/**
+ * Коды, возвращаемые методами dft_...
+ */
+enum DFT_CODE
+{
+	DFT_CODE_OK = 0,         /**< Метод успешно отработал. */
+	DFT_CODE_ALLOC_ERR = -1, /**< Ошибка выделения памяти. */
+};
+
+/**
+ * Таблицы sin и cos алгоритма Кули-Тьюки.
+ *
+ * Cooley J. W., Tukey J. W. An algorithm for the machine calculation of complex Fourier series, 1965 г.
+ */
+struct COOLEY_TUKEY
+{
+	hsv_numeric_t*sin_tab;
+	hsv_numeric_t*cos_tab;
+	unsigned tab_size;
+
+	int initialized;
+};
+
+/**
+ * Таблицы sin, cos и предрасчитанная часть свертки алгоритма Блюштейна.
+ *
+ * Bluestein L. A linear filtering approach to the computation of discrete Fourier transform, 1970 г.
+ */
+struct BLUESTEIN
+{
+	hsv_numeric_t*sin_tab;
+	hsv_numeric_t*cos_tab;
+	unsigned tab_size;	
+
+	hsv_numeric_t*a_real;
+	hsv_numeric_t*a_imag;
+
+	hsv_numeric_t*b_real;
+	hsv_numeric_t*b_imag;
+
+	hsv_numeric_t*c_real;
+	hsv_numeric_t*c_imag;
+
+	unsigned nb;
+
+	int initialized;
+};
+
+/**
+ * Структура ДПФ.
+ * При dft_size - степени двойки используется только алгоритм Кули-Тьюки, иначе оба алгоритма.
+ */
+struct DISCRETE_FOURIER_TRANSFORM
+{
+	hsv_numeric_t*real; /**< Действительная часть. */
+	hsv_numeric_t*imag; /**< Мнимая часть.         */
+	unsigned dft_size;  /**< Размер ДПФ.           */
+
+	struct COOLEY_TUKEY ct; /**< Вспомогательная структура алгоритма Кули-Тьюки, ускоряющая его работу. */
+	struct BLUESTEIN bl;    /**< Вспомогательная структура алгоритма Блюштейна, ускоряющая его работу.  */
+};
+
+typedef struct DISCRETE_FOURIER_TRANSFORM* dft_t;
+
+/**
+ * Создание структуры ДПФ.
+ * \return указатель на структуру ДПФ (при ошибке - NULL).
+ */
+dft_t create_dft();
+
+/**
+ * Конфигурация ДПФ.
+ * \param dft_size размер ДПФ.
+ * \return результат конфигурирования.
+ */
+enum DFT_CODE dft_config(dft_t dft, unsigned dft_size);
+
+/**
+ * Выполнение прямого ДПФ над массивами real и imag.
+ */
+void dft_run_dft(dft_t dft);
+
+/**
+ * Выполнение обратного ДПФ над массивами real и imag.
+ */
+void dft_run_i_dft(dft_t dft);
+
+/**
+ * Удаление всех внутренних динамических структур.
+ */
+void dft_deconfig(dft_t dft);
+
+/**
+ * Зануление структуры ДПФ.
+ */
+void dft_clean(dft_t dft);
+
+/**
+ * Удаление структуры ДПФ.
+ */
+void dft_free(dft_t dft);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_DFT_DFT_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/estimator/estimator.c ffmpeg/libavfilter/hsv/estimator/estimator.c
--- ffmpeg-orig/libavfilter/hsv/estimator/estimator.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/estimator/estimator.c	2020-05-31 09:08:09.494198000 +0300
@@ -0,0 +1,245 @@
+/**
+ * \file estimator.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API алгоритма оценивания шума.
+ */
+/**
+ * \ingroup estimator
+ * \{
+ */
+#include "estimator.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+estimator_t create_estimator()
+{
+	estimator_t est;
+
+	est = (estimator_t) calloc(1, sizeof(struct ESTIMATOR));
+	return est;
+}
+
+static void init_delta_k(hsv_numeric_t*delta_k, unsigned sr, unsigned size)
+{
+	/* Так как частоты человеческого голоса лежат в диапазоне 0..3000 Hz,
+	 причем основная часть диапазоне 0..1000 Hz, то для данных частот устанавливаются
+	 меньшие пороговые значения наличия речи. Исследования Лойзю и Рангачари показали,
+	 что универсальными порогами могут быть 2.0 для 0..1000HZ, 2.0 для 1000..3000Hz и
+	 5.0 для 3000..SR/2 HZ. В связи с частотой дискретизации, берущейся минимум x 2 (т. Котельникова)
+	 данные значения дельт отражаются симметрично относительно половина sr. */
+
+	static const hsv_numeric_t delta_lf = 2.0;
+	static const hsv_numeric_t delta_mf = 2.0;
+	static const hsv_numeric_t delta_hf = 5.0;
+
+	unsigned k;
+
+	hsv_numeric_t freq_res = ((hsv_numeric_t) sr) / ((hsv_numeric_t) size);
+	unsigned LF = HSV_FLOOR(1000.0 / freq_res);
+	unsigned MF = HSV_FLOOR(3000.0 / freq_res);
+
+	for (k = 0; k < LF; k++) {
+		delta_k[k] = delta_lf;
+	}
+	for (k = 0; k < MF - LF; k++) {
+		delta_k[k + LF] = delta_mf;
+	}
+	for (k = 0; k < (size / 2) - MF; k++) {
+		delta_k[k + MF] = delta_hf;
+	}
+	delta_k[size / 2] = 5.0;
+	for (k = 1; k < size / 2; k++) {
+		delta_k[size - k] = delta_k[k];
+	}
+}
+
+enum ESTIMATOR_CODE estimator_config(estimator_t est, unsigned sr, unsigned size)
+{
+	static const hsv_numeric_t alpha_smooth = 0.7;
+
+	static const hsv_numeric_t beta = 0.8;
+	static const hsv_numeric_t gamma = 0.998;
+
+	static const hsv_numeric_t alpha_spp = 0.2;
+	
+	static const hsv_numeric_t alpha = 0.95;
+	
+	
+	enum ESTIMATOR_CODE r;
+
+	est->size = size;
+
+	est->delta_k = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->delta_k == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err0;
+	}
+	init_delta_k(est->delta_k, sr, size);
+
+	est->alpha_smooth = alpha_smooth;
+	est->P = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->P == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	est->P_prev = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->P_prev == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err2;
+	}
+
+	est->beta = beta;
+	est->gamma = gamma;
+	est->P_min = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->P_min == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err3;
+	}
+	est->P_min_prev = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->P_min_prev == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err4;
+	}
+
+	est->alpha_spp = alpha_spp;
+	est->spp_k = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->spp_k == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err5;
+	}
+
+	est->alpha = alpha;
+
+	est->noise_power_spec = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->noise_power_spec == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err6;
+	}
+	est->noise_amp_spec = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (est->noise_amp_spec == NULL) {
+		r = ESTIMATOR_CODE_ALLOC_ERR;
+		goto err7;
+	}
+
+	return ESTIMATOR_CODE_OK;
+
+ err7:
+	free(est->noise_power_spec);
+ err6:
+	free(est->spp_k);
+ err5:
+	free(est->P_min_prev);
+ err4:
+	free(est->P_min);
+ err3:
+	free(est->P_prev);
+ err2:
+	free(est->P);
+ err1:
+	free(est->delta_k);
+ err0:
+	return r;
+}
+
+static void estimator_calculate_noise_amp_spec(estimator_t est)
+{
+	unsigned k;
+
+	for (k = 0; k < est->size; k++) {
+		est->noise_amp_spec[k] = HSV_SQRT(est->noise_power_spec[k]);
+	}
+}
+
+static void estimator_get_first(estimator_t est, hsv_numeric_t*P)
+{
+	memcpy(est->P, P, est->size * sizeof(hsv_numeric_t));
+	memcpy(est->P_prev, P, est->size * sizeof(hsv_numeric_t));
+
+	memcpy(est->P_min, P, est->size * sizeof(hsv_numeric_t));
+	memcpy(est->P_min_prev, P, est->size * sizeof(hsv_numeric_t));
+
+	memcpy(est->noise_power_spec, P, est->size * sizeof(hsv_numeric_t));
+	estimator_calculate_noise_amp_spec(est);
+	
+	est->got_first = 1;
+}
+
+static void estimator_process(estimator_t est, hsv_numeric_t*P)
+{
+	unsigned k;
+
+	/* Сглаживание спектра входного зашумленного сигнала. */
+	for (k = 0; k < est->size; k++) {
+		est->P[k] = est->alpha_smooth * est->P_prev[k] + (1.0 - est->alpha_smooth) * P[k];
+	}
+
+	memcpy(est->P_prev, est->P, est->size * sizeof(hsv_numeric_t));
+
+	/* Непрерывное отслеживание спектральных минимумов по Доблингеру. */
+	for (k = 0; k < est->size; k++) {
+		if (est->P_min_prev[k] < est->P[k]) {
+			est->P_min[k] = est->gamma * est->P_min_prev[k] + ((1.0 - est->gamma) / (1.0 - est->beta)) * (est->P[k] - est->beta * est->P_prev[k]);
+		} else {
+			est->P_min[k] = est->P[k];
+		}
+	}
+
+	memcpy(est->P_min_prev, est->P_min, est->size * sizeof(hsv_numeric_t));
+
+	/* Оценка спектра шума методом MCRA-2. */
+	for (k = 0; k < est->size; k++) {
+		hsv_numeric_t ak;
+		/* Апостериорный SNR сглаженного зашумленного голоса. */
+		hsv_numeric_t Sr_k = est->P[k] / est->P_min[k];
+		/* Бинарная оценка наличия голоса. */
+		hsv_numeric_t spp_k = 0.0;
+		if (Sr_k > est->delta_k[k]) {
+			spp_k = 1.0;
+		}
+		/* Сглаживание вероятности наличия голоса во времени. */
+		est->spp_k[k] = est->alpha_spp * est->spp_k[k] + (1.0 - est->alpha_spp) * spp_k;
+		/* Расчет коэффициента сглаживания шума в частотно-временной области. */
+		ak = est->alpha + (1.0 - est->alpha) * est->spp_k[k];
+		/* Итоговая оценка спектра шума. */
+		est->noise_power_spec[k] = ak * est->noise_power_spec[k] + (1.0 - ak) * est->P[k];
+	}
+
+	estimator_calculate_noise_amp_spec(est);
+}
+
+void estimator_run(estimator_t est, hsv_numeric_t*P)
+{
+	if (! est->got_first) {
+		estimator_get_first(est, P);
+	} else {
+		estimator_process(est, P);
+	}
+}
+
+void estimator_deconfig(estimator_t est)
+{
+	free(est->noise_amp_spec);
+	free(est->noise_power_spec);
+	free(est->spp_k);
+	free(est->P_min_prev);
+	free(est->P_min);
+	free(est->P_prev);
+	free(est->P);
+	free(est->delta_k);
+}
+
+void estimator_clean(estimator_t est)
+{
+	memset(est, '\0', sizeof(*est));
+}
+
+void estimator_free(estimator_t est)
+{
+	free(est);
+}
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/estimator/estimator.h ffmpeg/libavfilter/hsv/estimator/estimator.h
--- ffmpeg-orig/libavfilter/hsv/estimator/estimator.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/estimator/estimator.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,108 @@
+/**
+ * \file estimator.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief API алгоритма оценивания шума.
+ */
+/**
+ * \defgroup estimator Модуль оценивания шума.
+ * \{
+ */
+#ifndef AVFILTER_HSV_ESTIMATOR_ESTIMATOR_H
+#define AVFILTER_HSV_ESTIMATOR_ESTIMATOR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_types/hsv_types.h"
+
+/**
+ * Коды, возвращаемые методами estimator_...
+ */
+enum ESTIMATOR_CODE
+{
+	ESTIMATOR_CODE_OK = 0,         /**< Метод успешно отработал. */
+	ESTIMATOR_CODE_ALLOC_ERR = -1, /**< Ошибка выделения памяти. */
+};
+
+/**
+ * Структура оценки шума.
+ * Оценка шума базируется на алгоритме Лойзю-Рагначари MCRA-2,
+ * улучшенной версии алгоритма Кохена-Бердуго MCRA.
+ *
+ * Cohen I.,  Berdugo B.    А noise estimation by minima controlled recursive averaging for robust speech enhancement, 2002 г.
+ * Loizou P., Rangachari S. A noise estimation algorithm for highly nonstationary environments, Speech Communications, 2006 г.
+ * Doblinger G.             Computationally efficient speech enhancement by spectral minima tracking in subbands,      1995 г.
+ */
+struct ESTIMATOR
+{
+	unsigned sr;   /**< Частота дискретизации. */
+	unsigned size; /**< Размер фрейма.         */
+
+	hsv_numeric_t*delta_k; /**< Частотно-зависимые пороги присутствия голоса. */
+
+	hsv_numeric_t alpha_smooth; /**< Коэффициент сглаживания зашумленного сигнала во времени. */
+	hsv_numeric_t*P;            /**< Текущая оценка мощности спектра зашумленного сигнала.    */
+	hsv_numeric_t*P_prev;       /**< Прошлая оценка мощности спектра зашумленного сигнала.    */
+
+	hsv_numeric_t beta;       /**< Коэффициент прогнозирования.            */
+	hsv_numeric_t gamma;      /**< Коэффициент сглаживания.                */
+	hsv_numeric_t*P_min;      /**< Текущая оценка шума методом Доблингера. */
+	hsv_numeric_t*P_min_prev; /**< Прошлая оценка шума методом Доблингера. */
+
+	hsv_numeric_t alpha_spp; /**< Коэффициент сглаживания вероятности наличия голоса во времени. */
+	hsv_numeric_t*spp_k;     /**< Вероятность наличия голоса.                                    */
+
+	hsv_numeric_t alpha; /**< Вспомогательный коэффициент для расчет коэффициента сглажвания шума в частотно-временной области. */
+
+	hsv_numeric_t*noise_power_spec; /**< Спектр мощности шума. */
+	hsv_numeric_t*noise_amp_spec;   /**< Спектр амплитуд шума. */
+
+	int got_first; /**< Был ли получен первый фрейм. */
+};
+
+typedef struct ESTIMATOR* estimator_t;
+
+/**
+ * Создание структуры оценки шума.
+ * \return указатель на структуру оценки шума (при ошибке - NULL).
+ */
+estimator_t create_estimator();
+
+/**
+ * Конфигурация оценки шума.
+ * \param sr частота дискретизации.
+ * \param size размер анализируемого фрейма.
+ * \return результат конфигурирования.
+ */
+enum ESTIMATOR_CODE estimator_config(estimator_t est, unsigned sr, unsigned size);
+
+/**
+ * Выполнение оценки шума.
+ */
+void estimator_run(estimator_t est, hsv_numeric_t*P);
+
+/**
+ * Удаление всех внутренних динамических структур.
+ */
+void estimator_deconfig(estimator_t est);
+
+/**
+ * Зануление структуры оценки шума.
+ */
+void estimator_clean(estimator_t est);
+
+/**
+ * Удаление структуры оценки шума.
+ */
+void estimator_free(estimator_t est);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_ESTIMATOR_ESTIMATOR_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/hsv.c ffmpeg/libavfilter/hsv/hsv.c
--- ffmpeg-orig/libavfilter/hsv/hsv.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/hsv.c	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,413 @@
+/**
+ * \file hsv.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API алгоритма шумоочистки "Hubbub Suppression for Voice" ("HSV")
+ */
+/**
+ * \ingroup hsv
+ * \{
+ */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_interface.h"
+#include "hsv_priv.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <inttypes.h>
+
+hsvc_t create_hsvc()
+{
+	hsvc_t hsvc;
+
+	hsvc = (hsvc_t) calloc(1, sizeof(struct HSV_CONTEXT));
+	return hsvc;
+}
+
+int hsvc_validate_config(const struct HSV_CONFIG*conf)
+{
+	struct HSV_CONFIG tmp = *conf;
+	
+	if (tmp.sr == 0) {
+		return 1;
+	} else if (tmp.ch == 0) {
+		return 2;
+	} else if (tmp.bs != HSV_SUPPORTED_BS) {
+		return 3;
+	}
+
+	if ((tmp.mode < HSV_SUPPRESSOR_MODE_SPECSUB) || (tmp.mode > HSV_SUPPRESSOR_MODE_RTSNR_G)) {
+		return 4;
+	}
+
+	if (tmp.frame_size_smpls == HSV_DEFAULT) {
+		tmp.frame_size_smpls = (unsigned) HSV_FLOOR(2.0 * tmp.sr / 100.0);
+	}
+
+	if (tmp.overlap_perc == HSV_DEFAULT) {
+		tmp.overlap_perc = HSV_DEFAULT_OVERLAP_PERC;
+	} else if (tmp.overlap_perc >= 100) {
+		return 6;
+	}
+
+	if (tmp.dft_size_smpls == HSV_DEFAULT) {
+		tmp.dft_size_smpls = 2 * tmp.frame_size_smpls;
+	} else if (tmp.dft_size_smpls < tmp.frame_size_smpls) {
+		return 7;
+	}
+
+	if (tmp.cap != HSV_DEFAULT) {
+		if ((tmp.cap % 2 != 0) || (tmp.cap < tmp.frame_size_smpls)) {
+			return 8;
+		}
+	}
+
+	return HSV_CODE_OK;
+}
+
+static enum HSV_CODE switch_rb_code(enum RB_CODE r)
+{
+	switch (r) {
+	case RB_CODE_OK:
+		return HSV_CODE_OK;
+	case RB_CODE_ALLOC_ERR:
+		return HSV_CODE_ALLOC_ERR;
+	case RB_CODE_OVERFLOW_ERR:
+		return HSV_CODE_OVERFLOW_ERR;
+	default:
+		return HSV_CODE_UNKNOWN_ERR;
+	}
+}
+
+static enum HSV_CODE switch_dft_code(enum RB_CODE r)
+{
+	switch (r) {
+	case DFT_CODE_OK:
+		return HSV_CODE_OK;
+	case DFT_CODE_ALLOC_ERR:
+		return HSV_CODE_ALLOC_ERR;
+	default:
+		return HSV_CODE_UNKNOWN_ERR;
+	}
+}
+
+static enum HSV_CODE switch_estimator_code(enum ESTIMATOR_CODE r)
+{
+	switch (r) {
+	case ESTIMATOR_CODE_OK:
+		return HSV_CODE_OK;
+	case ESTIMATOR_CODE_ALLOC_ERR:
+		return HSV_CODE_ALLOC_ERR;
+	default:
+		return HSV_CODE_UNKNOWN_ERR;
+	}
+}
+
+static enum HSV_CODE switch_suppressor_code(enum SUPPRESSOR_CODE r)
+{
+	switch (r) {
+	case SUPPRESSOR_CODE_OK:
+		return HSV_CODE_OK;
+	case SUPPRESSOR_CODE_ALLOC_ERR:
+		return HSV_CODE_ALLOC_ERR;
+	default:
+		return HSV_CODE_UNKNOWN_ERR;
+	}
+}
+
+static enum HSV_CODE hsvc_config_chan(struct HSV_CHAN*chan, unsigned sr, unsigned dft_size_smpls, enum HSV_SUPPRESSOR_MODE mode)
+{
+	enum HSV_CODE r;
+
+	enum DFT_CODE dft_r;
+	enum ESTIMATOR_CODE est_r;
+	enum SUPPRESSOR_CODE sup_r;
+
+	dft_r = dft_config(&(chan->dft), dft_size_smpls);
+	if (dft_r != DFT_CODE_OK) {
+		r = switch_dft_code(dft_r);
+		goto err0;
+	}
+	
+	chan->amp_spec = (hsv_numeric_t*) calloc(dft_size_smpls, sizeof(hsv_numeric_t));
+	if (chan->amp_spec == NULL) {
+		r = HSV_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	chan->power_spec = (hsv_numeric_t*) calloc(dft_size_smpls, sizeof(hsv_numeric_t));
+	if (chan->power_spec == NULL) {
+		r = HSV_CODE_ALLOC_ERR;
+		goto err2;
+	}
+	chan->phase_spec = (hsv_numeric_t*) calloc(dft_size_smpls, sizeof(hsv_numeric_t));
+	if (chan->phase_spec == NULL) {
+		r = HSV_CODE_ALLOC_ERR;
+		goto err3;
+	}
+	
+	est_r = estimator_config(&(chan->est), sr, dft_size_smpls);
+	if (est_r != ESTIMATOR_CODE_OK) {
+		r = switch_estimator_code(est_r);
+		goto err4;
+	}
+
+	sup_r = suppressor_config(&(chan->sup), sr, dft_size_smpls, mode);
+	if (sup_r != SUPPRESSOR_CODE_OK) {
+		r = switch_suppressor_code(sup_r);
+		goto err5;
+	}
+	
+	chan->overlap_buf = (hsv_numeric_t*) calloc(dft_size_smpls, sizeof(hsv_numeric_t));
+	if (chan->overlap_buf == NULL) {
+		r = HSV_CODE_ALLOC_ERR;
+		goto err6;
+	}
+
+	return HSV_CODE_OK;
+
+ err6:
+	suppressor_deconfig(&(chan->sup));
+ err5:
+	estimator_deconfig(&(chan->est));
+ err4:
+	free(chan->phase_spec);
+ err3:
+	free(chan->power_spec);
+ err2:
+	free(chan->amp_spec);
+ err1:
+	dft_deconfig(&(chan->dft));
+ err0:
+	return r;
+}
+
+static void hsvc_deconfig_chan(struct HSV_CHAN*chan)
+{
+	free(chan->overlap_buf);
+
+	suppressor_deconfig(&(chan->sup));
+	estimator_deconfig(&(chan->est));
+
+	free(chan->phase_spec);
+	free(chan->power_spec);
+	free(chan->amp_spec);
+
+	dft_deconfig(&(chan->dft));
+}
+
+enum HSV_CODE hsvc_config(hsvc_t hsvc, const struct HSV_CONFIG*conf)
+{
+	enum HSV_CODE r;
+
+	enum RB_CODE rb_r;
+
+	unsigned ch, k;
+
+	hsvc->conf = *conf;
+
+	if (hsvc->conf.cap == HSV_DEFAULT) {
+		hsvc->conf.cap = HSV_DEFAULT_CAP;
+	}
+	rb_r = rb_config(&(hsvc->rb), hsvc->conf.cap);
+	if (rb_r != RB_CODE_OK) {
+		r = switch_rb_code(rb_r);
+		goto err0;
+	}
+
+	if (hsvc->conf.frame_size_smpls == HSV_DEFAULT) {
+		hsvc->conf.frame_size_smpls = (unsigned) HSV_FLOOR(2.0 * hsvc->conf.sr / 100.0);
+	}
+	hsvc->frame_size_smpls = hsvc->conf.frame_size_smpls;
+	if (hsvc->frame_size_smpls % 2 == 1) {
+		hsvc->frame_size_smpls++;
+	}
+	if (hsvc->conf.overlap_perc == HSV_DEFAULT) {
+		hsvc->conf.overlap_perc = HSV_DEFAULT_OVERLAP_PERC;
+	}
+	hsvc->overlap_size_smpls = (unsigned) HSV_FLOOR(hsvc->frame_size_smpls * hsvc->conf.overlap_perc / 100.0);
+	hsvc->step_size_smpls = hsvc->frame_size_smpls - hsvc->overlap_size_smpls;
+
+	hsvc->frame_size_bs = hsvc->frame_size_smpls * 2 * hsvc->conf.ch;
+	hsvc->overlap_size_bs = hsvc->overlap_size_smpls * 2 * hsvc->conf.ch;
+	hsvc->step_size_bs = hsvc->step_size_smpls * 2 * hsvc->conf.ch;
+
+	hsvc->norm_factor = 1.0 / ((100.0 - hsvc->conf.overlap_perc) / 100.0);
+
+	if (hsvc->conf.dft_size_smpls == HSV_DEFAULT) {
+		hsvc->conf.dft_size_smpls = hsvc->frame_size_smpls * 2;
+	}
+	hsvc->dft_size_smpls = hsvc->conf.dft_size_smpls;
+
+	hsvc->window = (hsv_numeric_t*) calloc(hsvc->frame_size_smpls, sizeof(hsv_numeric_t));
+	if (hsvc->window == NULL) {
+		r = HSV_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	init_window(hsvc->window, hsvc->frame_size_smpls, WINDOW_TYPE_HANNING);
+
+	for (ch = 0; ch < hsvc->conf.ch; ch++) {
+		r = hsvc_config_chan(hsvc->chans + ch, hsvc->conf.sr, hsvc->dft_size_smpls, hsvc->conf.mode);
+		if (r != HSV_CODE_OK) {
+			goto err2;
+		}
+	}
+
+	return HSV_CODE_OK;
+
+ err2:
+	for (k = 0; k < ch; k++) {
+		hsvc_deconfig_chan(hsvc->chans + ch);
+	}
+ err1:
+	rb_deconfig(&(hsvc->rb));
+ err0:
+	return r;
+}
+
+static hsv_numeric_t int16_to_hsv_numeric_t(int16_t v)
+{
+	static const hsv_numeric_t one = 1.0;
+    static const hsv_numeric_t max_int16_inv = one / INT16_MAX;
+    static const hsv_numeric_t min_int16_inv = one / INT16_MIN;
+
+    return v * ((v > 0) ? max_int16_inv : -min_int16_inv);
+}
+
+static int16_t hsv_numeric_t_to_int16(hsv_numeric_t v)
+{
+	static const hsv_numeric_t half = 0.5;
+	
+    if (v > 0) {
+        return (v >= 1) ? INT16_MAX : ((int16_t) (v * INT16_MAX + half));
+    } else {
+        return (v <= -1) ? INT16_MIN : ((int16_t) (-v * INT16_MIN - half));
+    }
+}
+
+static int hsvc_denoise(hsvc_t hsvc)
+{
+	unsigned ch, k;
+
+	unsigned processed = 0;
+
+	/* До тех пор пока кол-во байт, ожидающих обработку,
+	   превышает размер одного фрейма, будем их обрабатывать. */
+	while (hsvc->pending_bytes >= hsvc->frame_size_bs) {
+		/* Структура многоканального WAV-файла подразумевает, что данные каналов лежат через один:
+		   если есть 2 канала A и B, то данные лежат как ABABAB... . Поэтому обрабатываем каналы по очереди. */
+        for (ch = 0; ch < hsvc->conf.ch; ch++) {
+			/* Считываем очередной фрейм одного канала из кольцевого буфера в буфер обработки. */
+			memset(hsvc->chans[ch].dft.real, '\0', sizeof(hsv_numeric_t) * hsvc->chans[ch].dft.dft_size);
+			memset(hsvc->chans[ch].dft.imag, '\0', sizeof(hsv_numeric_t) * hsvc->chans[ch].dft.dft_size);
+            for (k = 0; k < hsvc->frame_size_smpls; k++) {
+				hsvc->chans[ch].dft.real[k] =
+					int16_to_hsv_numeric_t(((int16_t*)hsvc->rb.data)[((hsvc->idx_frame / 2) + k * hsvc->conf.ch + ch) % (rb_cap(&(hsvc->rb)) / 2)]);
+            }
+
+			/* Применяем оконную функцию, для уменьшения эффекта растекания. */
+			calculate_windowing(hsvc->window, hsvc->chans[ch].dft.real, hsvc->chans[ch].dft.real, hsvc->frame_size_smpls);
+			
+			dft_run_dft(&(hsvc->chans[ch].dft));
+
+			calculate_amp_spec(hsvc->chans[ch].dft.real, hsvc->chans[ch].dft.imag,
+							   hsvc->chans[ch].amp_spec, hsvc->chans[ch].dft.dft_size);
+			calculate_power_spec(hsvc->chans[ch].dft.real, hsvc->chans[ch].dft.imag,
+								 hsvc->chans[ch].power_spec, hsvc->chans[ch].dft.dft_size);
+			calculate_phase_spec(hsvc->chans[ch].dft.real, hsvc->chans[ch].dft.imag,
+								 hsvc->chans[ch].phase_spec, hsvc->chans[ch].dft.dft_size);
+
+			estimator_run(&(hsvc->chans[ch].est), hsvc->chans[ch].power_spec);
+
+			suppressor_run(&(hsvc->chans[ch].sup), hsvc->chans[ch].amp_spec, hsvc->chans[ch].est.noise_amp_spec);
+
+			/* Будем считать, что спектры фаз голоса, шума и зашумленного голоса совпадают. */
+			for (k = 0; k < hsvc->chans[ch].dft.dft_size; k++) {
+				hsvc->chans[ch].dft.real[k] = hsvc->chans[ch].sup.speech_amp_spec[k] * HSV_COS(hsvc->chans[ch].phase_spec[k]);
+				hsvc->chans[ch].dft.imag[k] = hsvc->chans[ch].sup.speech_amp_spec[k] * HSV_SIN(hsvc->chans[ch].phase_spec[k]);
+			}
+
+			dft_run_i_dft(&(hsvc->chans[ch].dft));
+
+			/* Записываем результаты обработки очередного фрейма одного канала из буфера обработки обратно в кольцевой буфер с учетом перекрытия. */
+			for (k = 0; k < hsvc->step_size_smpls; k++) {
+				hsvc->pending_bytes -= 2; processed += 2;
+                ((int16_t*)hsvc->rb.data)[((hsvc->idx_frame / 2) + k * hsvc->conf.ch + ch) % (rb_cap(&(hsvc->rb)) / 2)] =
+					hsv_numeric_t_to_int16(hsvc->chans[ch].dft.real[k] / hsvc->norm_factor + hsvc->chans[ch].overlap_buf[k]);
+			}
+
+			/* Так как для уменьшения эффекта блочности используется перекрытие, сохраним данные, полученные при обработке n-го фрейма
+			   для их использования при обработке n+1-го, n+2-го и т.д. фреймов. */
+			for (k = 0; k < hsvc->chans[ch].dft.dft_size; k++) {
+				hsvc->chans[ch].overlap_buf[k] += hsvc->chans[ch].dft.real[k] / hsvc->norm_factor;
+			}
+			memmove(hsvc->chans[ch].overlap_buf, hsvc->chans[ch].overlap_buf + hsvc->step_size_smpls, (hsvc->chans[ch].dft.dft_size - hsvc->step_size_smpls) * sizeof(hsv_numeric_t));
+			memset(hsvc->chans[ch].overlap_buf + (hsvc->chans[ch].dft.dft_size - hsvc->step_size_smpls), '\0', hsvc->step_size_smpls * sizeof(hsv_numeric_t));
+		}
+		/* Учтём, что часть фрейма может лежать "в конце" кольцевого буфера, а часть "в начале". */
+		hsvc->idx_frame = (hsvc->idx_frame + hsvc->step_size_bs) % rb_cap(&(hsvc->rb));
+	}
+
+	return processed;
+}
+
+int hsvc_push(hsvc_t hsvc, const char*data, unsigned data_len)
+{
+	enum HSV_CODE r;
+
+	enum RB_CODE rb_r;
+
+	rb_r = rb_push(&(hsvc->rb), data, data_len);
+	if (rb_r != RB_CODE_OK) {
+		r = switch_rb_code(rb_r);
+		goto err0;
+	}
+
+	hsvc->pending_bytes += data_len;
+
+	return hsvc_denoise(hsvc);
+ err0:
+	return r;
+}
+
+unsigned hsvc_get(hsvc_t hsvc, char*data, unsigned data_cap)
+{
+	unsigned data_len = rb_len(&(hsvc->rb)) - hsvc->pending_bytes;
+	if (data_cap < data_len) {
+		data_len = data_cap;
+	}
+	return rb_get(&(hsvc->rb), data, data_len);
+}
+
+void hsvc_flush(hsvc_t hsvc)
+{
+    hsvc->idx_frame = rb_idx_in(&(hsvc->rb));
+    hsvc->pending_bytes = 0;
+}
+
+void hsvc_deconfig(hsvc_t hsvc)
+{
+	unsigned ch;
+
+	for (ch = 0; ch < hsvc->conf.ch; ch++) {
+		hsvc_deconfig_chan(hsvc->chans + ch);
+	}
+
+	free(hsvc->window);
+	rb_deconfig(&hsvc->rb);
+}
+
+void hsvc_clean(hsvc_t hsvc)
+{
+	memset(hsvc, '\0', sizeof(*hsvc));
+}
+
+void hsvc_free(hsvc_t hsvc)
+{
+	free(hsvc);
+}
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/hsv_priv.h ffmpeg/libavfilter/hsv/hsv_priv.h
--- ffmpeg-orig/libavfilter/hsv/hsv_priv.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/hsv_priv.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,87 @@
+/**
+ * \file hsv_priv.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Внутреннее API алгоритма шумоочистки "Hubbub Suppression for Voice" ("HSV")
+ */
+/**
+ * \ingroup hsv
+ * \{
+ */
+#ifndef AVFILTER_HSV_HSV_PRIV_H
+#define AVFILTER_HSV_HSV_PRIV_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_interface.h"
+
+#include "./hsv_types/hsv_types.h"
+
+#include "./rb/rb.h"
+#include "./utils/utils.h"
+#include "./dft/dft.h"
+#include "./estimator/estimator.h"
+#include "./suppressor/suppressor.h"
+
+/**
+ * Структура одного канала звука.
+ */
+struct HSV_CHAN
+{
+	struct DISCRETE_FOURIER_TRANSFORM dft; /**< Структура ДПФ. */
+
+	hsv_numeric_t*amp_spec;   /**< Текущий спектр амплитуд. */
+	hsv_numeric_t*power_spec; /**< Текущий спектр мощности. */
+	hsv_numeric_t*phase_spec; /**< Текущий спектр фаз.      */
+
+	struct ESTIMATOR est; /**< Структура оценки шума. */
+
+	struct SUPPRESSOR sup; /**< Структура подавления шума. */
+
+	/**
+	 * Буфер перекрытия для хранения данных,
+	 * полученных при обработке предыдущих фреймов.
+	 */
+	hsv_numeric_t*overlap_buf;
+};
+
+
+/**
+ * Структура контекста \"HSV\"
+ */
+struct HSV_CONTEXT
+{
+	struct HSV_CONFIG conf; /**< Параметры конфигурации. */
+
+	struct RING_BUFFER rb; /**< Кольцевой буфер. */
+
+	unsigned frame_size_smpls;   /**< Размер обрабатываемого фрейма в сэмплах. */
+	unsigned overlap_size_smpls; /**< Размер перекрытия фреймов в сэмплах.     */
+	unsigned step_size_smpls;    /**< Размер шага фрейма в сэмплах.            */
+
+	unsigned frame_size_bs;   /**< Размер обрабатываемого фрейма в байтах с учетом числа каналов. */
+	unsigned overlap_size_bs; /**< Размер перекрытия фреймов в байтах с учетом числа каналов.     */
+	unsigned step_size_bs;    /**< Размер шага фрейма в байтах с учетом числа каналов.            */
+
+	hsv_numeric_t norm_factor; /**< Фактор нормализации данных при перекрытии. */
+
+	unsigned dft_size_smpls; /**< Размер ДПФ. */
+
+	hsv_numeric_t*window; /**< Оконная функция. */
+
+	struct HSV_CHAN chans[HSV_MAX_CHANS]; /**< Обрабатываемые каналы звука. */
+
+	unsigned idx_frame;     /**< Индекс начала фрейма в кольцевом буфере.            */
+	unsigned pending_bytes; /**< Число байт в кольцевом буфере, ожидающих обработки. */
+};
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_HSV_PRIV_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/hsv_types/hsv_types.h ffmpeg/libavfilter/hsv/hsv_types/hsv_types.h
--- ffmpeg-orig/libavfilter/hsv/hsv_types/hsv_types.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/hsv_types/hsv_types.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,87 @@
+/**
+ * \file hsv_types.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Alias'ы типов данных и функций с плавающей точкой, используемых для анализа звука.
+ */
+/**
+ * \defgroup hsv_types Модуль типов "HSV".
+ * \{
+ */
+#ifndef AVFILTER_HSV_HSV_TYPES_HSV_TYPES_H
+#define AVFILTER_HSV_HSV_TYPES_HSV_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+#define PREFIX_UNUSED(VAR) ((void) VAR) /**< Макрос подавления неиспользуемых переменных. */
+
+/**
+ * Выбор режима точности вычислений с плавающей точкой.
+ * LOW_ACC  - низкая точность  (float);
+ * MED_ACC  - средняя точность (double);
+ * HIGH_ACC - высокая точность (long double);
+ */
+#define LOW_ACC 
+
+#ifdef LOW_ACC
+
+typedef float hsv_numeric_t;
+
+#define HSV_SIN(VAR) sinf(VAR)
+#define HSV_COS(VAR) cosf(VAR)
+#define HSV_ATAN2(VAR_A, VAR_B) atan2f(VAR_A, VAR_B)
+#define HSV_SQRT(VAR) sqrtf(VAR)
+#define HSV_POW(VAR_A, VAR_B) powf(VAR_A, VAR_B)
+#define HSV_ROUND(VAR) roundf(VAR)
+#define HSV_LOG10(VAR) log10f(VAR)
+#define HSV_FLOOR(VAR) floorf(VAR)
+	
+#endif  /* LOW_ACC */
+
+#ifdef MED_ACC
+
+typedef double hsv_numeric_t;
+
+#define HSV_SIN(VAR) sin(VAR)
+#define HSV_COS(VAR) cos(VAR)
+#define HSV_ATAN2(VAR_A, VAR_B) atan2(VAR_A, VAR_B)
+#define HSV_SQRT(VAR) sqrt(VAR)
+#define HSV_POW(VAR_A, VAR_B) pow(VAR_A, VAR_B)
+#define HSV_ROUND(VAR) round(VAR)
+#define HSV_LOG10(VAR) log10(VAR)
+#define HSV_FLOOR(VAR) floor(VAR)
+	
+#endif  /* MED_ACC */
+
+#ifdef HIGH_ACC
+
+typedef long double hsv_numeric_t;
+
+#define HSV_SIN(VAR) sinl(VAR)
+#define HSV_COS(VAR) cosl(VAR)
+#define HSV_ATAN2(VAR_A, VAR_B) atan2l(VAR_A, VAR_B)
+#define HSV_SQRT(VAR) sqrtl(VAR)
+#define HSV_POW(VAR_A, VAR_B) powl(VAR_A, VAR_B)
+#define HSV_ROUND(VAR) roundl(VAR)
+#define HSV_LOG10(VAR) log10l(VAR)
+#define HSV_FLOOR(VAR) floorl(VAR)
+
+#endif  /* HIGH_ACC */
+
+#ifndef M_PI
+#define M_PI ((hsv_numeric_t) 3.14159265358979323846)
+#endif	/* M_PI */
+
+#define HSV_MAX(VAR_A, VAR_B) ((VAR_A) > (VAR_B) ? (VAR_A) : (VAR_B))
+#define HSV_MIN(VAR_A, VAR_B) ((VAR_A) < (VAR_B) ? (VAR_A) : (VAR_B))
+#define HSV_ABS(VAR) (((VAR) >= 0.0) ? (VAR) : - (VAR))
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_HSV_TYPES_HSV_TYPES_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/Makefile ffmpeg/libavfilter/hsv/Makefile
--- ffmpeg-orig/libavfilter/hsv/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/Makefile	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,8 @@
+OBJS-$(CONFIG_HSV) += hsv/rb/rb.o
+OBJS-$(CONFIG_HSV) += hsv/utils/utils.o
+OBJS-$(CONFIG_HSV) += hsv/dft/dft.o
+OBJS-$(CONFIG_HSV) += hsv/estimator/estimator.o
+OBJS-$(CONFIG_HSV) += hsv/suppressor/suppressor.o	
+OBJS-$(CONFIG_HSV) += hsv/hsv.o
+
+OBJS-$(CONFIG_HSV) += $(HSV-OBJS-yes)
diff -ruN ffmpeg-orig/libavfilter/hsv/rb/rb.c ffmpeg/libavfilter/hsv/rb/rb.c
--- ffmpeg-orig/libavfilter/hsv/rb/rb.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/rb/rb.c	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,120 @@
+/**
+ * \file rb.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API буферизации.
+ */
+/**
+ * \ingroup rb
+ * \{
+ */
+#include "rb.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+rb_t create_rb()
+{
+	rb_t rb;
+
+	rb = (rb_t) calloc(1, sizeof(struct RING_BUFFER));
+	return rb;
+}
+
+enum RB_CODE rb_config(rb_t rb, unsigned cap)
+{
+	enum RB_CODE r;
+
+	rb->data = (char*) calloc(cap, sizeof(char));
+	if (rb->data == NULL) {
+		r = RB_CODE_ALLOC_ERR;
+		goto err0;
+	}
+
+	rb->cap = cap;
+
+	return RB_CODE_OK;
+
+ err0:
+	return r;
+}
+
+unsigned rb_len(const rb_t rb)
+{
+	return rb->len;
+}
+
+unsigned rb_cap(const rb_t rb)
+{
+	return rb->cap;
+}
+
+unsigned rb_idx_in(const rb_t rb)
+{
+	return rb->idx_in;
+}
+
+unsigned rb_idx_out(const rb_t rb)
+{
+	return rb->idx_out;
+}
+
+enum RB_CODE rb_push(rb_t rb, const char*data, unsigned data_len)
+{
+    unsigned i;
+    
+    if ((data_len + rb_len(rb)) > rb_cap(rb)) {
+        return RB_CODE_OVERFLOW_ERR;
+    }
+
+    for (i = 0; i < data_len; i++) {
+        rb->len++;
+        rb->data[rb->idx_in] = data[i];
+		rb->idx_in++;
+        if (rb->idx_in >= rb->cap) {
+            rb->idx_in = 0;
+        }
+    }
+
+    return RB_CODE_OK;
+}
+
+unsigned rb_get(rb_t rb, char*data, unsigned data_cap)
+{
+    unsigned i;
+    
+    unsigned data_len;
+
+	data_len = rb_len(rb);
+    if (data_cap < data_len) {
+        data_len = data_cap;
+    }
+
+    for (i = 0; i < data_len; i++) {
+        rb->len--;
+        data[i] = rb->data[rb->idx_out];
+		rb->idx_out++;
+        if (rb->idx_out >= rb->cap) {
+            rb->idx_out = 0;
+        }
+    }
+
+    return data_len;
+}
+
+void rb_deconfig(rb_t rb)
+{
+	free(rb->data);
+}
+
+void rb_clean(rb_t rb)
+{
+	memset(rb, '\0', sizeof(*rb));
+}
+
+void rb_free(rb_t rb)
+{
+	free(rb);
+}
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/rb/rb.h ffmpeg/libavfilter/hsv/rb/rb.h
--- ffmpeg-orig/libavfilter/hsv/rb/rb.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/rb/rb.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,114 @@
+/**
+ * \file rb.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief API буферизации.
+ */
+/**
+ * \defgroup rb Модуль буферизации.
+ * \{
+ */
+#ifndef AVFILTER_HSV_RB_RB_H
+#define AVFILTER_HSV_RB_RB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/**
+ * Коды, возвращаемые методами rb_...
+ */
+enum RB_CODE
+{
+	RB_CODE_OK = 0,            /**< Метод успешно отработал.    */
+	RB_CODE_ALLOC_ERR    = -1, /**< Ошибка выделения памяти.    */
+	RB_CODE_OVERFLOW_ERR = -2, /**< Ошибка переполнения буфера. */
+};
+
+/**
+ * Структура кольцевого буфера.
+ */
+struct RING_BUFFER
+{
+	char*data; /**< Массив бинарных данных. */
+
+	unsigned len; /**< Размер данных в буфере.          */
+	unsigned cap; /**< Максимальная вместимость буфера. */
+
+	unsigned idx_in;  /**< Указатель на текущее место записи. */
+	unsigned idx_out; /**< Указатель на текущее место чтения. */
+};
+
+typedef struct RING_BUFFER* rb_t;
+
+/**
+ * Создание структуры кольцевого буфера.
+ * \return указатель на структуру кольцевого буфера (при ошибке - NULL).
+ */
+rb_t create_rb();
+
+/**
+ * Конфигурация кольцевого буфера.
+ * \param cap вместимость кольцевого буфера.
+ * \return результат конфигурирования.
+ */
+enum RB_CODE rb_config(rb_t rb, unsigned cap);
+
+/**
+ * \return размер данных в буфере.
+ */
+unsigned rb_len(const rb_t rb);
+
+/**
+ * \return вместимость данных в буфере.
+ */
+unsigned rb_cap(const rb_t rb);
+
+/**
+ * \return индекс массива буфера, в который будут добавляться элементы.
+ */
+unsigned rb_idx_in(const rb_t rb);
+
+/**
+ * \return индекс массива буфера, из которого будут браться элементы.
+ */
+unsigned rb_idx_out(const rb_t rb);
+
+/**
+ * Запись данных в кольцевой буфер.
+ * \param data массив бинарных данных для чтения.
+ * \param data_len размер массива.
+ * \return результат записи.
+ */
+enum RB_CODE rb_push(rb_t rb, const char*data, unsigned data_len);
+
+/**
+ * Чтение данных из кольцевого буфера.
+ * \param data массив бинарных данных для записи.
+ * \param data_cap вместимость массива.
+ * \return число считанных байт.
+ */
+unsigned rb_get(rb_t rb, char*data, unsigned data_cap);
+
+/**
+ * Удаление всех внутренних динамических структур.
+ */
+void rb_deconfig(rb_t rb);
+
+/**
+ * Зануление структуры кольцевого буфера.
+ */
+void rb_clean(rb_t rb);
+
+/**
+ * Удаление структуры кольцевого буфера.
+ */
+void rb_free(rb_t rb);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_RB_RB_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/suppressor/suppressor.c ffmpeg/libavfilter/hsv/suppressor/suppressor.c
--- ffmpeg-orig/libavfilter/hsv/suppressor/suppressor.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/suppressor/suppressor.c	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,544 @@
+/**
+ * \file suppressor.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API алгоритм шумоподавления.
+ */
+/**
+ * \ingroup suppressor
+ * \{
+ */
+#include "suppressor.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+suppressor_t create_suppressor()
+{
+	suppressor_t sup;
+
+	sup = (suppressor_t) calloc(1, sizeof(struct SUPPRESSOR));
+	return sup;
+}
+
+static enum SUPPRESSOR_CODE specsub_config(struct SUPPRESSOR_SPECSUB*specsub, unsigned sr, unsigned size)
+{
+	const hsv_numeric_t power_exponent = 2.0;
+
+	specsub->sr = sr;
+	specsub->size = size;
+
+	specsub->power_exponent = power_exponent;
+
+	return SUPPRESSOR_CODE_OK;
+}
+
+static void specsub_deconfig(struct SUPPRESSOR_SPECSUB*specsub)
+{
+	PREFIX_UNUSED(specsub);
+}
+
+static enum SUPPRESSOR_CODE wiener_config(struct SUPPRESSOR_WIENER*wiener, unsigned sr, unsigned size)
+{
+	static const hsv_numeric_t beta = 0.98;
+	static const hsv_numeric_t floor = 0.01;
+
+	enum SUPPRESSOR_CODE r;
+
+	wiener->sr = sr;
+	wiener->size = size;
+
+	wiener->beta = beta;
+	wiener->floor = floor;
+
+	wiener->noise_power_spec = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->noise_power_spec == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err0;
+	}
+
+	wiener->SNR_inst = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->SNR_inst == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	wiener->SNR_prio_dd = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->SNR_prio_dd == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err2;
+	}
+	wiener->G_dd = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->G_dd == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err3;
+	}
+	
+	wiener->speech_amp_spec = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->speech_amp_spec == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err4;
+	}
+	wiener->speech_amp_spec_prev = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (wiener->speech_amp_spec_prev == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err5;
+	}
+
+	return SUPPRESSOR_CODE_OK;
+
+ err5:
+	free(wiener->speech_amp_spec);
+ err4:
+	free(wiener->G_dd);
+ err3:
+	free(wiener->SNR_prio_dd);
+ err2:
+	free(wiener->SNR_inst);
+ err1:
+	free(wiener->noise_power_spec);
+ err0:
+	return r;
+}
+
+static void wiener_deconfig(struct SUPPRESSOR_WIENER*wiener)
+{
+	free(wiener->speech_amp_spec_prev);
+	free(wiener->speech_amp_spec);
+
+	free(wiener->G_dd);
+	free(wiener->SNR_prio_dd);
+	free(wiener->SNR_inst);
+
+	free(wiener->noise_power_spec);
+}
+
+static enum SUPPRESSOR_CODE gain_config(struct SUPPRESSOR_GAIN*gain, unsigned sr, unsigned size)
+{
+	enum DFT_CODE dft_r;
+	
+	enum SUPPRESSOR_CODE r;
+
+	PREFIX_UNUSED(sr);
+
+	gain->L1 = size;
+	gain->L2 = gain->L1 / 2;
+	
+	dft_r = dft_config(&(gain->dft), size);
+	if (dft_r != DFT_CODE_OK) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err0;
+	}
+	gain->window = (hsv_numeric_t*) calloc(gain->L2, sizeof(hsv_numeric_t));
+	if (gain->window == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	init_window(gain->window, gain->L2, WINDOW_TYPE_HAMMING);
+	gain->impulse_response_before = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (gain->impulse_response_before == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err2;
+	}
+	gain->impulse_response_after = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (gain->impulse_response_after == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err3;
+	}
+
+	return SUPPRESSOR_CODE_OK;
+
+ err3:
+	free(gain->impulse_response_before);
+ err2:
+	free(gain->window);
+ err1:
+	dft_deconfig(&(gain->dft));
+ err0:
+	return r;
+}
+
+static void gain_deconfig(struct SUPPRESSOR_GAIN*gain)
+{
+	free(gain->impulse_response_after);
+	free(gain->impulse_response_before);
+	free(gain->window);
+	dft_deconfig(&(gain->dft));
+}
+
+static enum SUPPRESSOR_CODE tsnr_config(struct SUPPRESSOR_TSNR*tsnr, unsigned sr, unsigned size, enum SUPPRESSOR_MODE mode)
+{
+	enum SUPPRESSOR_CODE r;
+
+	tsnr->mode = mode;
+
+	r = wiener_config(&(tsnr->wiener), sr, size);
+	if (r != SUPPRESSOR_CODE_OK) {
+		goto err0;
+	}
+
+	tsnr->SNR_prio_2_step = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (tsnr->SNR_prio_2_step == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err1;
+	}
+	tsnr->G_2_step = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (tsnr->G_2_step == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err2;
+	}
+
+	if ((mode == SUPPRESSOR_MODE_TSNR_G) || (mode == SUPPRESSOR_MODE_RTSNR_G)) {
+		r = gain_config(&(tsnr->gain), sr, size);
+		if (r != SUPPRESSOR_CODE_OK) {
+			goto err3;
+		}
+	}
+
+	return SUPPRESSOR_CODE_OK;
+
+ err3:
+	free(tsnr->G_2_step);
+ err2:
+	free(tsnr->SNR_prio_2_step);
+ err1:
+	wiener_deconfig(&(tsnr->wiener));
+ err0:
+	return r;
+}
+
+static void tsnr_deconfig(struct SUPPRESSOR_TSNR*tsnr)
+{
+	if ((tsnr->mode == SUPPRESSOR_MODE_TSNR_G) || (tsnr->mode == SUPPRESSOR_MODE_RTSNR_G)) {
+		gain_deconfig(&(tsnr->gain));
+	}
+
+	free(tsnr->G_2_step);
+	free(tsnr->SNR_prio_2_step);
+
+	wiener_deconfig(&(tsnr->wiener));
+}
+
+enum SUPPRESSOR_CODE suppressor_config(suppressor_t sup, unsigned sr, unsigned size, enum SUPPRESSOR_MODE mode)
+{
+	enum SUPPRESSOR_CODE r;
+
+	sup->sr = sr;
+	sup->size = size;
+
+	sup->mode = mode;
+
+	switch (mode) {
+	case SUPPRESSOR_MODE_SPECSUB:
+		r = specsub_config(&(sup->specsub), sr, size);
+		break;
+	case SUPPRESSOR_MODE_WIENER:
+		r = wiener_config(&(sup->wiener), sr, size);
+		break;
+	case SUPPRESSOR_MODE_TSNR:
+	case SUPPRESSOR_MODE_TSNR_G:
+	case SUPPRESSOR_MODE_RTSNR:
+	case SUPPRESSOR_MODE_RTSNR_G:
+		r = tsnr_config(&(sup->tsnr), sr, size, mode);
+		break;
+	default:
+		return SUPPRESSOR_CODE_INVALID_MODE;
+	}
+
+	if (r != SUPPRESSOR_CODE_OK) {
+		goto err0;
+	}
+
+	sup->speech_amp_spec = (hsv_numeric_t*) calloc(size, sizeof(hsv_numeric_t));
+	if (sup->speech_amp_spec == NULL) {
+		r = SUPPRESSOR_CODE_ALLOC_ERR;
+		goto err1;
+	}
+
+	return SUPPRESSOR_CODE_OK;
+
+ err1:
+	switch (sup->mode) {
+	case SUPPRESSOR_MODE_SPECSUB:
+		specsub_deconfig(&(sup->specsub));
+		break;
+	case SUPPRESSOR_MODE_WIENER:
+		wiener_deconfig(&(sup->wiener));
+		break;
+	case SUPPRESSOR_MODE_TSNR:
+	case SUPPRESSOR_MODE_TSNR_G:
+	case SUPPRESSOR_MODE_RTSNR:
+	case SUPPRESSOR_MODE_RTSNR_G:
+		tsnr_deconfig(&(sup->tsnr));
+		break;
+	}
+ err0:
+	return r;
+}
+
+static hsv_numeric_t specsub_calculate_SNR_post(const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec, unsigned size)
+{
+	unsigned k;
+
+	hsv_numeric_t noisy_speech_power = 0.0;
+	hsv_numeric_t noise_power = 0.0;
+
+	for (k = 0; k < size; k++) {
+		noisy_speech_power += noisy_speech_amp_spec[k] * noisy_speech_amp_spec[k];
+		noise_power += noise_amp_spec[k] * noise_amp_spec[k];
+	}
+
+	return 10.0 * HSV_LOG10(noisy_speech_power / noise_power);
+}
+
+static hsv_numeric_t specsub_calculate_alpha(hsv_numeric_t snr_post)
+{
+	static const hsv_numeric_t min = -5.0;
+	static const hsv_numeric_t max = 20.0;
+	static const hsv_numeric_t alpha0 = 4.0;
+
+	hsv_numeric_t alpha;
+
+	if ((snr_post >= min) && (snr_post <= max)) {
+		alpha = alpha0 - snr_post * 3.0 / ((hsv_numeric_t) max);
+	} else if (snr_post < min) {
+		alpha = 5.0;
+	} else /* if (snr_post > max) */ { /* Чтобы GCC не кидал Warning'и при компиляции. */
+		alpha = 1.0;
+	}
+
+	return alpha;
+}
+
+static hsv_numeric_t specsub_calculate_beta(hsv_numeric_t snr_post)
+{
+	hsv_numeric_t beta;
+
+	if (snr_post > 0.0) {
+		beta = 0.01;
+	} else if (snr_post < -5.0) {
+		beta = 0.04;
+	} else {
+		beta = 0.02;
+	}
+
+	return beta;
+}
+
+static void specsub_run(struct SUPPRESSOR_SPECSUB*specsub, const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec, hsv_numeric_t*out)
+{
+	unsigned k;
+
+	/* Апостериорный SNR. */
+	unsigned SNR_post = specsub_calculate_SNR_post(noisy_speech_amp_spec, noise_amp_spec, specsub->size);
+	/* alpha является основным параметром вычитания. */
+	hsv_numeric_t alpha = specsub_calculate_alpha(SNR_post);
+	/* beta маскиррует "музыкальный шум" с помощью остаточного шума. */
+	hsv_numeric_t beta = specsub_calculate_beta(SNR_post);
+
+	for (k = 0; k < specsub->size; k++) {
+		hsv_numeric_t tmp;
+		if (HSV_POW(noisy_speech_amp_spec[k], specsub->power_exponent) > (alpha + beta) * HSV_POW(noise_amp_spec[k], specsub->power_exponent)) {
+			/* Вычитание. */
+			tmp = HSV_POW(noisy_speech_amp_spec[k], specsub->power_exponent) - alpha * HSV_POW(noise_amp_spec[k], specsub->power_exponent);
+		} else {
+			/* Маскировка "музыкального" шума остаточным шумом. */
+			tmp = beta * HSV_POW(noise_amp_spec[k], specsub->power_exponent);
+		}
+
+		out[k] = HSV_POW(tmp, 1.0 / specsub->power_exponent);
+	}
+}
+
+static void wiener_run(struct SUPPRESSOR_WIENER*wiener, const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec, hsv_numeric_t*out)
+{
+	unsigned i;
+
+	/* Вычисление спектра мощности шума. */
+	for (i = 0; i < wiener->size; i++) {
+		wiener->noise_power_spec[i] = noise_amp_spec[i] * noise_amp_spec[i];
+	}
+	/* Вычисление мгновенного SNR по Скалару-Филхо: мгновенный SNR_inst = апостериорный SNR - 1.
+	   Минимальное значение используется для уменьшения искажения сигнала. */
+	for (i = 0; i < wiener->size; i++) {
+		hsv_numeric_t noisy_speech_power_spec = noisy_speech_amp_spec[i] * noisy_speech_amp_spec[i];
+		hsv_numeric_t SNR_post = noisy_speech_power_spec / wiener->noise_power_spec[i];
+		wiener->SNR_inst[i] = HSV_MAX(SNR_post - 1.0, wiener->floor);
+	}
+	/* Вычисление априорного SNR по методу принятия решений Эфраима-Малаха. */
+	for (i = 0; i < wiener->size; i++) {
+		wiener->SNR_prio_dd[i] = wiener->beta * ((wiener->speech_amp_spec_prev[i] * wiener->speech_amp_spec_prev[i]) / wiener->noise_power_spec[i]) +
+			(1.0 - wiener->beta) * wiener->SNR_inst[i];
+	}
+	/* Вычисление коэффициентов фильтра Винера. */
+	for (i = 0; i < wiener->size; i++) {
+		wiener->G_dd[i] = wiener->SNR_prio_dd[i] / (wiener->SNR_prio_dd[i] + 1.0);
+	}
+	/* Винеровская фильтрация. */
+	for (i = 0; i < wiener->size; i++) {
+		wiener->speech_amp_spec[i] = wiener->G_dd[i] * noisy_speech_amp_spec[i];
+	}
+
+	memcpy(wiener->speech_amp_spec_prev, wiener->speech_amp_spec, wiener->size * sizeof(hsv_numeric_t));
+	memcpy(out, wiener->speech_amp_spec, wiener->size * sizeof(hsv_numeric_t));
+}
+
+static void suppressor_gain(struct SUPPRESSOR_GAIN*gain, hsv_numeric_t*G_2_step)
+{
+	unsigned i;
+
+	hsv_numeric_t mean_gain_before = 0.0;
+	hsv_numeric_t mean_gain_after = 0.0;
+
+	/* Считаем среднее значение фильтра до его "усиления". */
+	for (i = 0; i < gain->L1; i++) {
+		mean_gain_before += G_2_step[i] * G_2_step[i];
+	}
+	mean_gain_before /= gain->L1;
+	/* Переходим из частотной области во временную. */
+	for (i = 0; i < gain->L1; i++) {
+		gain->dft.real[i] = G_2_step[i]; gain->dft.imag[i] = 0.0;
+	}
+	dft_run_i_dft(&(gain->dft));
+	/* Получаем неограниченный импульсной характеристики фильтра во времени. */
+	memcpy(gain->impulse_response_before, gain->dft.real, gain->L1 * sizeof(hsv_numeric_t));
+	/* На её базе строим новый ограниченный фильтр по Скалару. */
+	for (i = 0; i < gain->L2 / 2; i++) {
+		gain->impulse_response_after[i] = gain->impulse_response_before[i] * gain->window[i + gain->L2 / 2];
+	}
+	for (i = 0; i < gain->L2; i++) {
+		gain->impulse_response_after[i + gain->L2 / 2] = 0.0;
+	}
+	for (i = 0; i < gain->L2 / 2; i++) {
+		gain->impulse_response_after[i + gain->L2 / 2 + gain->L2] = gain->impulse_response_before[gain->L2 + gain->L2 / 2 + i] * gain->window[i];
+	}
+	/* Переходим обратно во временную область. */
+	for (i = 0; i < gain->L1; i++) {
+		gain->dft.real[i] = gain->impulse_response_after[i];
+		gain->dft.imag[i] = 0.0;
+	}
+	dft_run_dft(&(gain->dft));
+	/* Получаем "усиленный" фильтр. */
+	calculate_amp_spec(gain->dft.real, gain->dft.imag, G_2_step, gain->L1);
+	/* Считаем среднее значение фильтра после его "усиления". */
+	for (i = 0; i < gain->L1; i++) {
+		mean_gain_after += G_2_step[i] * G_2_step[i];
+	}
+	mean_gain_after /= gain->L1;
+	/* Нормализуем полученный фильтр. */
+	for (i = 0; i < gain->L1; i++) {
+		G_2_step[i] = G_2_step[i] * HSV_SQRT(mean_gain_before / mean_gain_after);
+	}
+}
+
+static void tsnr_run(struct SUPPRESSOR_TSNR*tsnr, const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec, hsv_numeric_t*out)
+{
+	unsigned i;
+
+	/* Вычисление спектра мощности шума. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->wiener.noise_power_spec[i] = noise_amp_spec[i] * noise_amp_spec[i];
+	}
+	/* Вычисление мгновенного SNR по Скалару-Филхо: мгновенный SNR_inst = апостериорный SNR - 1.
+	   Минимальное значение используется для уменьшения искажения сигнала. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		hsv_numeric_t noisy_speech_power_spec = noisy_speech_amp_spec[i] * noisy_speech_amp_spec[i];
+		hsv_numeric_t SNR_post = noisy_speech_power_spec / tsnr->wiener.noise_power_spec[i];
+		tsnr->wiener.SNR_inst[i] = HSV_MAX(SNR_post - 1.0, tsnr->wiener.floor);
+	}
+	/* Вычисление априорного SNR по методу принятия решений Эфраима-Малаха. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->wiener.SNR_prio_dd[i] = tsnr->wiener.beta * ((tsnr->wiener.speech_amp_spec_prev[i] * tsnr->wiener.speech_amp_spec_prev[i]) / tsnr->wiener.noise_power_spec[i]) +
+			(1.0 - tsnr->wiener.beta) * tsnr->wiener.SNR_inst[i];
+	}
+	/* Вычисление коэффициентов фильтра Винера. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->wiener.G_dd[i] = tsnr->wiener.SNR_prio_dd[i] / (tsnr->wiener.SNR_prio_dd[i] + 1.0);
+	}
+	/*  Винеровская фильтрация. Получили результат аналогичный алгоритму Скалара-Филхо 96-го. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		if ((tsnr->mode == SUPPRESSOR_MODE_TSNR) || (tsnr->mode == SUPPRESSOR_MODE_TSNR_G)) {
+			tsnr->wiener.speech_amp_spec[i] = tsnr->wiener.G_dd[i] * noisy_speech_amp_spec[i];
+		} else {
+			tsnr->wiener.speech_amp_spec[i] = (2.0 - tsnr->wiener.G_dd[i]) * tsnr->wiener.G_dd[i] * noisy_speech_amp_spec[i];
+		}
+	}
+	/* Скалар предложил итеративно повторять процедуру 96-го, для борьбы с запаздыванием априорного SNR на 1 фрейм.
+	   Эксперименты показали, что 1 дополнительная итерация значительно влияет на качестве шумоочистки.
+	   Остальные незначительно. Вычисление априорного SNR очищенного сигнала. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->SNR_prio_2_step[i] = (tsnr->wiener.speech_amp_spec[i] * tsnr->wiener.speech_amp_spec[i]) / tsnr->wiener.noise_power_spec[i];
+	}
+	/* Вычисление коэффициентов фильтра Винера. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->G_2_step[i] = tsnr->SNR_prio_2_step[i] / (tsnr->SNR_prio_2_step[i] + 1.0);
+	}
+
+	if ((tsnr->mode == SUPPRESSOR_MODE_TSNR) || (tsnr->mode == SUPPRESSOR_MODE_RTSNR)) {
+		for (i = 0; i < tsnr->wiener.size; i++) {
+			tsnr->G_2_step[i] = HSV_MAX(tsnr->G_2_step[i], tsnr->wiener.floor);
+		}
+	} else {
+		/* Дополнительная функция "усиления", предложенная Скаларом-Плапусом. */
+		suppressor_gain(&(tsnr->gain), tsnr->G_2_step);		
+	}
+
+	/* Применение Винеровского фильтра. */
+	for (i = 0; i < tsnr->wiener.size; i++) {
+		tsnr->wiener.speech_amp_spec[i] = tsnr->G_2_step[i] * noisy_speech_amp_spec[i];
+	}
+
+	memcpy(tsnr->wiener.speech_amp_spec_prev, tsnr->wiener.speech_amp_spec, tsnr->wiener.size * sizeof(hsv_numeric_t));
+	memcpy(out, tsnr->wiener.speech_amp_spec, tsnr->wiener.size * sizeof(hsv_numeric_t));
+}
+
+void suppressor_run(suppressor_t sup, const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec)
+{
+	switch (sup->mode) {
+	case SUPPRESSOR_MODE_SPECSUB:
+		specsub_run(&(sup->specsub), noisy_speech_amp_spec, noise_amp_spec, sup->speech_amp_spec);
+		break;
+	case SUPPRESSOR_MODE_WIENER:
+		wiener_run(&(sup->wiener), noisy_speech_amp_spec, noise_amp_spec, sup->speech_amp_spec);
+		break;
+	case SUPPRESSOR_MODE_TSNR:
+	case SUPPRESSOR_MODE_TSNR_G:
+	case SUPPRESSOR_MODE_RTSNR:
+	case SUPPRESSOR_MODE_RTSNR_G:
+		tsnr_run(&(sup->tsnr), noisy_speech_amp_spec, noise_amp_spec, sup->speech_amp_spec);
+		break;
+	}
+}
+
+void suppressor_deconfig(suppressor_t sup)
+{
+	free(sup->speech_amp_spec);
+
+	switch (sup->mode) {
+	case SUPPRESSOR_MODE_SPECSUB:
+		specsub_deconfig(&(sup->specsub));
+		break;
+	case SUPPRESSOR_MODE_WIENER:
+		wiener_deconfig(&(sup->wiener));
+		break;
+	case SUPPRESSOR_MODE_TSNR:
+	case SUPPRESSOR_MODE_TSNR_G:
+	case SUPPRESSOR_MODE_RTSNR:
+	case SUPPRESSOR_MODE_RTSNR_G:
+		tsnr_deconfig(&(sup->tsnr));
+		break;
+	}
+}
+
+void suppressor_clean(suppressor_t sup)
+{
+	memset(sup, '\0', sizeof(*sup));
+}
+
+void suppressor_free(suppressor_t sup)
+{
+	free(sup);
+}
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/suppressor/suppressor.h ffmpeg/libavfilter/hsv/suppressor/suppressor.h
--- ffmpeg-orig/libavfilter/hsv/suppressor/suppressor.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/suppressor/suppressor.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,196 @@
+/**
+ * \file suppressor.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief API алгоритм шумоподавления.
+ */
+/**
+ * \defgroup suppressor Модуль подавления шума.
+ * \{
+ */
+#ifndef AVFILTER_HSV_SUPPRESSOR_SUPPRESSOR_H
+#define AVFILTER_HSV_SUPPRESSOR_SUPPRESSOR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_types/hsv_types.h"
+
+#include "../dft/dft.h"
+#include "../utils/utils.h"
+
+/**
+ * Коды, возвращаемые методами suppressor_...
+ */
+enum SUPPRESSOR_CODE
+{
+	SUPPRESSOR_CODE_OK           =  0, /**< Метод успешно отработал. */
+	SUPPRESSOR_CODE_INVALID_MODE = -1, /**< Неизвестный режим.       */
+	SUPPRESSOR_CODE_ALLOC_ERR    = -2, /**< Ошибка выделения памяти. */
+};
+
+/**
+ * Режим работы алгоритма шумоподавления.
+ */
+enum SUPPRESSOR_MODE
+{
+	SUPPRESSOR_MODE_SPECSUB, /**< Режим, основанный на спектральном вычитании Берути. */
+
+	SUPPRESSOR_MODE_WIENER,  /**< Режим, основанный на винеровской фильтрации Скалара. */
+
+	SUPPRESSOR_MODE_TSNR,    /**< Режим, основанный на двухшаговой фильтрации Скалара.               */
+	SUPPRESSOR_MODE_TSNR_G,  /**< Режим, основанный на двухшаговой фильтрации Скалара с "усилением". */
+
+	SUPPRESSOR_MODE_RTSNR,   /**< Режим, основанный на двухшаговой фильтрации Шифенга.               */
+	SUPPRESSOR_MODE_RTSNR_G, /**< Режим, основанный на двухшаговой фильтрации Шифенга с "усилением". */
+};
+
+/**
+ * Структура спектрального вычитания.
+ * Вычитание базируется на алгоритмах Берути-Шварца.
+ *
+ * Berouti M., Schwartz M., Makhoul J. Enhancement of speech corrupted by acoustic noise,
+ * Proceedings of IEEE International Conference on Acoustic Speech Signal Processing, 1979 г.
+ */
+struct SUPPRESSOR_SPECSUB
+{
+	unsigned sr;   /**< Частота дискретизации. */
+	unsigned size; /**< Размер фрейма.         */
+	/**
+	 * Степень, в которую возводятся спектры амплитуд и шума при вычитании.
+	 * 1.0 - вычитание спектров амплитуд по Боллу.
+	 * 2.0 - вычитание спектров мощности по Берути.
+	 */
+	hsv_numeric_t power_exponent;
+};
+
+/**
+ * Структура винеровской фильтрации.
+ * Фильтрация базируется на алгоритме Скалара-Филхо.
+ *
+ * Ephraim Y., Malah D., Speech Enhancement Using a Minimum Mean-Square Error
+ * Short-Time Spectral Amplitude Estimator, 1984 г.
+ *
+ * Scalart P., Filho J. V. Speech enhancement based on a priori signal to noise estimation,
+ * Acoustics, Speech, and Signal Processing, 1996 г.
+ */
+struct SUPPRESSOR_WIENER
+{
+	unsigned sr;   /**< Частота дискретизации. */
+	unsigned size; /**< Размер фрейма.         */
+
+	hsv_numeric_t beta;  /**< Коэффициент метода принятия решений.                  */
+	hsv_numeric_t floor; /**< Коэффициент сглаживания для предотвращения искажений. */
+
+	hsv_numeric_t*noise_power_spec; /**< Спектр мощности шума. */
+
+	hsv_numeric_t*SNR_inst;    /**< Мгновенный SNR.                                     */
+	hsv_numeric_t*SNR_prio_dd; /**< Априорный SNR, полученный методом принятия решений. */
+	hsv_numeric_t*G_dd;        /**< Фильтр винера.                                      */
+
+	hsv_numeric_t*speech_amp_spec;      /**< Текущий спектр амплитуд голоса. */
+	hsv_numeric_t*speech_amp_spec_prev; /**< Прошлый спектр амплитуд голоса. */
+};
+
+/**
+ * Структура вычисления фильтра "усиления".
+ */
+struct SUPPRESSOR_GAIN
+{
+	unsigned L1; /**< Размер фильтра. */
+	unsigned L2; /**< Размер окна.    */
+
+	struct DISCRETE_FOURIER_TRANSFORM dft; /**< Структура ДПФ. */
+
+	hsv_numeric_t*window; /**< Оконная функция. */
+
+	hsv_numeric_t*impulse_response_before; /**< Импульсный отклик до усиления.    */
+	hsv_numeric_t*impulse_response_after;  /**< Импульсный отклик после усиления. */
+};
+
+/**
+ * Структура двухшаговой фильтрации.
+ * Фильтрация базируется на алгоритмах Скалара и Шифенга.
+ *
+ * Scalart P., Plapous C. A two-step noise reduction technique,
+ * Acoustics, Speech, and Signal Processing, 2004 г.
+ *
+ * Shifeng Ou., Chao G., Ying G. Improved a Priori SNR Estimation for Speech Enhancement Incorporating Speech Distortion Component,
+ * Institute of Science and Technology for Opto-electronic Information, 2013 г.
+ */
+struct SUPPRESSOR_TSNR
+{
+	enum SUPPRESSOR_MODE mode; /**< Режим работа алгоритма шумоподавления. */
+	
+	struct SUPPRESSOR_WIENER wiener; /**< Структура винеровской фильтрации Скалара. */
+
+	hsv_numeric_t*SNR_prio_2_step; /**< Априорный SNR, полученный двухшаговым методом. */
+	hsv_numeric_t*G_2_step;        /**< Фильтр винера.                                 */
+
+	struct SUPPRESSOR_GAIN gain; /**< Улучшенный фильтр усилениея. */
+};
+
+/**
+ * Структура шумоподавления.
+ */
+struct SUPPRESSOR
+{
+	enum SUPPRESSOR_MODE mode; /**< Режим работа алгоритма шумоподавления. */
+
+	unsigned sr;   /**< Частота дискретизации. */
+	unsigned size; /**< Размер фрейма.         */
+
+	union {
+		struct SUPPRESSOR_SPECSUB specsub; /**< Структура алгоритма спектрального вычитания Берути-Шварца.           */
+		struct SUPPRESSOR_WIENER  wiener;  /**< Структура алгоритма винеровской фильтрации Скалара.                  */
+		struct SUPPRESSOR_TSNR    tsnr;    /**< Общая структура алгоритмов двухшаговой фильтрации Скалара и Шифенга. */
+	};
+
+	hsv_numeric_t*speech_amp_spec; /**< Спектр амплитуд очищенного голоса. */
+};
+
+typedef struct SUPPRESSOR* suppressor_t;
+
+/**
+ * Создание структуры подавления шума.
+ * \return указатель на структуру подавления шума (при ошибке - NULL).
+ */
+suppressor_t create_suppressor();
+
+/**
+ * Конфигурация подавления шума.
+ * \param sr частота дискретизации.
+ * \param size размер анализируемого фрейма.
+ * \return результат конфигурирования.
+ */
+enum SUPPRESSOR_CODE suppressor_config(suppressor_t sup, unsigned sr, unsigned size, enum SUPPRESSOR_MODE mode);
+
+/**
+ * Выполнение подавления шума.
+ */
+void suppressor_run(suppressor_t sup, const hsv_numeric_t*noisy_speech_amp_spec, const hsv_numeric_t*noise_amp_spec);
+
+/**
+ * Удаление всех внутренних динамических структур.
+ */
+void suppressor_deconfig(suppressor_t sup);
+
+/**
+ * Зануление структуры оценки шума.
+ */
+void suppressor_clean(suppressor_t sup);
+
+/**
+ * Удаление структуры оценки шума.
+ */
+void suppressor_free(suppressor_t sup);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_SUPPRESSOR_SUPPRESSOR_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv/utils/utils.c ffmpeg/libavfilter/hsv/utils/utils.c
--- ffmpeg-orig/libavfilter/hsv/utils/utils.c	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/utils/utils.c	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,101 @@
+/**
+ * \file utils.c
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Реализация API вспомогательных алгоритмов
+ */
+/**
+ * \ingroup utils
+ * \{
+ */
+#include "utils.h"
+
+#include <math.h>
+
+static hsv_numeric_t hamming(unsigned i, unsigned n)
+{
+	static const hsv_numeric_t A0 = 0.538360;
+	static const hsv_numeric_t A1 = 0.461640;
+	
+	return A0 - A1 * HSV_COS(((hsv_numeric_t) 2.0) * ((hsv_numeric_t) M_PI) * (i / ((hsv_numeric_t) n)));
+}
+
+static void init_hamming_window(hsv_numeric_t*window, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		window[i] = hamming(i, n);
+	}
+}
+
+static hsv_numeric_t hanning(unsigned i, unsigned n)
+{
+	static const hsv_numeric_t A0 = 0.5;
+	static const hsv_numeric_t A1 = 0.5;
+	
+	return A0 - A1 * HSV_COS(((hsv_numeric_t) 2.0) * ((hsv_numeric_t) M_PI) * (i / ((hsv_numeric_t) n)));
+}
+
+static void init_hanning_window(hsv_numeric_t*window, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		window[i] = hanning(i, n);
+	}
+}
+
+void init_window(hsv_numeric_t*window, unsigned n, enum WINDOW_TYPE wt)
+{
+	switch (wt) {
+	case WINDOW_TYPE_HAMMING:
+		init_hamming_window(window, n);
+		break;
+	case WINDOW_TYPE_HANNING:
+		init_hanning_window(window, n);
+		break;
+	default:
+		init_hamming_window(window, n);
+		break;
+	}
+}
+
+void calculate_windowing(const hsv_numeric_t*window, const hsv_numeric_t*in, hsv_numeric_t*out, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		out[i] = in[i] * window[i];
+	}
+}
+
+void calculate_amp_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*amp_spec, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		amp_spec[i] = HSV_SQRT(real[i] * real[i] + imag[i] * imag[i]);
+	}
+}
+
+void calculate_power_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*power_spec, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		power_spec[i] = real[i] * real[i] + imag[i] * imag[i];
+	}
+}
+
+void calculate_phase_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*phase_spec, unsigned n)
+{
+	unsigned i;
+
+	for (i = 0; i < n; i++) {
+		phase_spec[i] = HSV_ATAN2(imag[i], real[i]);
+	}
+}
+/**
+ * /}
+ */
+
diff -ruN ffmpeg-orig/libavfilter/hsv/utils/utils.h ffmpeg/libavfilter/hsv/utils/utils.h
--- ffmpeg-orig/libavfilter/hsv/utils/utils.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv/utils/utils.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,68 @@
+/**
+ * \file utils.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief API вспомогательных алгоритмов
+ */
+/**
+ * \defgroup utils Модуль вспомогательных функций работы со спектром.
+ * \{
+ */
+#ifndef AVFILTER_HSV_UTILS_UTILS_H
+#define AVFILTER_HSV_UTILS_UTILS_H
+
+#ifdef __cplusplus
+// extern "C" {
+#endif  /* __cplusplus */
+
+/* Относительные импорты, т.к. FFmpeg не поддерживает абсолютные. */
+#include "../hsv_types/hsv_types.h"
+
+enum WINDOW_TYPE
+{
+	/**
+	 * Оконная функция Хэмминга.
+	 * w(n) = 0.53836 - 0.46164 * cos(2 * Pi * n / (N - 1))
+	 */
+	WINDOW_TYPE_HAMMING,
+	/**
+	 * Оконная функция Хэннинга (Ханна).
+	 * w(n) = 0.5 * (1 - cos(2 * Pi * n / (N - 1)))
+	 */
+	WINDOW_TYPE_HANNING,
+};
+
+/**
+ * Инициализация массива оконной функции.
+ * \param n размер массива.
+ * \param wt тип окна.
+ */
+void init_window(hsv_numeric_t*window, unsigned n, enum WINDOW_TYPE wt);
+
+/**
+ * Перемножение с оконной функцией.
+ */
+void calculate_windowing(const hsv_numeric_t*window, const hsv_numeric_t*in, hsv_numeric_t*out, unsigned n);
+
+/**
+ * Вычисление спектра амплитуд сигнала.
+ */
+void calculate_amp_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*amp_spec, unsigned n);
+
+/**
+ * Вычисление спектра мощности сигнала.
+ */
+void calculate_power_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*power_spec, unsigned n);
+
+/**
+ * Вычисление спектра фаз сигнала.
+ */
+void calculate_phase_spec(const hsv_numeric_t*real, const hsv_numeric_t*imag, hsv_numeric_t*phase_spec, unsigned n);
+
+#ifdef __cplusplus
+// }
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_UTILS_UTILS_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/hsv_interface.h ffmpeg/libavfilter/hsv_interface.h
--- ffmpeg-orig/libavfilter/hsv_interface.h	1970-01-01 03:00:00.000000000 +0300
+++ ffmpeg/libavfilter/hsv_interface.h	2020-05-31 08:40:48.813985000 +0300
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2020 Mikhail Masyagin
+ *
+ * This file is NOT part of FFmpeg.
+ */
+/**
+ * \file hsv.h
+ * \author Masyagin M.M., masyagin1998@yandex.ru
+ * \brief Публичное API алгоритма шумоочистки "Hubbub Suppression for Voice" ("HSV").
+ */
+/**
+ * \defgroup hsv Модуль "HSV".
+ * \{
+ */
+#ifndef AVFILTER_HSV_INTERFACE_H
+#define AVFILTER_HSV_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+#define HSV_MAX_CHANS 4 /**< Максимальное число одновременно обрабатываемых каналов. */
+
+#define HSV_DEFAULT 0 /**< Значение по умолчанию для всех параметром. */
+
+#define HSV_SUPPORTED_BS 16 /**< Поддерживаемый размер одного сэмпла в битах. */
+
+#define HSV_DEFAULT_CAP 16384 /**< Вместимость кольцевого буфера по умолчанию в байтах. */
+
+#define HSV_DEFAULT_OVERLAP_PERC 50 /**< Процент перекрытия фреймов по умолчанию. */
+
+/**
+ * Режим работы алгоритма шумоподавления.
+ * Копия enum'а из suppressor.h
+ * Нужна для того, чтобы все API модуля "HSV" было в одном файле (для FFmpeg).
+ */
+enum HSV_SUPPRESSOR_MODE
+{
+	HSV_SUPPRESSOR_MODE_SPECSUB, /**< Режим, основанный на спектральном вычитании Берути. */
+
+	HSV_SUPPRESSOR_MODE_WIENER,  /**< Режим, основанный на винеровской фильтрации Скалара. */
+
+	HSV_SUPPRESSOR_MODE_TSNR,    /**< Режим, основанный на двухшаговой фильтрации Скалара.               */
+	HSV_SUPPRESSOR_MODE_TSNR_G,  /**< Режим, основанный на двухшаговой фильтрации Скалара с "усилением". */
+
+	HSV_SUPPRESSOR_MODE_RTSNR,   /**< Режим, основанный на двухшаговой фильтрации Шифенга.               */
+	HSV_SUPPRESSOR_MODE_RTSNR_G, /**< Режим, основанный на двухшаговой фильтрации Шифенга с "усилением". */
+};
+
+/**
+ * Коды, возвращаемые методами hsv_...
+ */
+enum HSV_CODE
+{
+	HSV_CODE_OK = 0,              /**< Метод успешно отработал.    */
+	HSV_CODE_ALLOC_ERR = -1,      /**< Ошибка выделения памяти.    */
+	HSV_CODE_OVERFLOW_ERR = -2,   /**< Ошибка переполнения буфера. */
+	HSV_CODE_UNKNOWN_ERR = -1024, /**< Неизвестная ошибка.         */
+};
+
+/**
+ * Структура конфигурации \"HSV\".
+ * Значения sr, ch и bs должны быть ненулевыми.
+ * Остальные в случае нулевых значений принимают значения по умолчанию.
+ */
+struct HSV_CONFIG
+{
+	/**
+	 * Частота дискретизации.
+	 * Должна быть ненулевой.
+	 */
+	unsigned sr;
+	/**
+	 * Число каналов.
+	 * Должно быть ненулевым и не превышать HSV_MAX_CHANS.
+	 */
+	unsigned ch;
+	/**
+	 * Размер одного сэмпла в битах.
+	 * Должен совпадать с HSV_SUPPORTED_BS.
+	 */
+	unsigned bs;
+
+	/**
+	 * Режим работы алгоритма шумоподавления.
+	 */
+	enum HSV_SUPPRESSOR_MODE mode;
+
+	/**
+	 * Размер обрабатываемого фрейма в сэмпах.
+	 * Рекомендуются значения 2.0 * sr / 100.0 или близкие к ним степени двойки.
+	 */
+	unsigned frame_size_smpls;
+	/**
+	 * Процент перекрытия фреймов.
+	 * Рекомендуются значения 50-75%.
+	 */
+	unsigned overlap_perc;
+	/**
+	 * Размер ДПФ в сэмплах.
+	 * Рекомендуется брать как удвоенный размер фрейма для увеличения частотного разрешения.
+	 */
+	unsigned dft_size_smpls;
+	/**
+	 * Вместимость кольцевого буфера в байтах.
+	 * Должна быть четной и достаточно большой для упреждения задержек.
+	 */
+	unsigned cap;
+};
+
+/**
+ * Структура контекста \"HSV\".
+ */
+struct HSV_CONTEXT;
+
+typedef struct HSV_CONTEXT* hsvc_t;
+
+/**
+ * Создание структуры \"HSV\".
+ * \return указатель на структуру \"HSV\" (при ошибке - NULL).
+ */
+hsvc_t create_hsvc();
+
+/**
+ * Проверка корректности структуры конфигурации.
+ * \return 0 при корректной конфигуации, номер первого некорректного поля (с 1) при некорректной.
+ */
+int hsvc_validate_config(const struct HSV_CONFIG*conf);
+
+/**
+ * Конфигурация \"HSV\".
+ * \param conf структура конфигурации \"HSV\".
+ * \return результат конфигурирования.
+ */
+enum HSV_CODE hsvc_config(hsvc_t hsvc, const struct HSV_CONFIG*conf);
+
+/**
+ * Запись данных и их шумоочистка.
+ * \param data массив бинарных данных для чтения.
+ * \param data_len размер массива.
+ * \return если >= 0, то число обработанных данных, иначе код ошибки.
+ */
+int hsvc_push(hsvc_t hsvc, const char*data, unsigned data_len);
+
+/**
+ * Чтение данных из кольцевого буфера.
+ * \param data массив бинарных данных для записи.
+ * \param data_cap вместимость массива.
+ * \return число считанных байт.
+ */
+unsigned hsvc_get(hsvc_t hsvc, char*data, unsigned data_cap);
+
+/**
+ * Сброс внутреннего счетчика фреймов для получения необработанных данных.
+ */
+void hsvc_flush(hsvc_t hsvc);
+
+/**
+ * Удаление всех внутренних динамических структур.
+ */
+void hsvc_deconfig(hsvc_t hsvc);
+
+/**
+ * Зануление структуры \"HSV\".
+ */
+void hsvc_clean(hsvc_t hsvc);
+
+/**
+ * Удаление структуры \"HSV\".
+ */
+void hsvc_free(hsvc_t hsvc);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* AVFILTER_HSV_INTERFACE_H */
+/**
+ * /}
+ */
diff -ruN ffmpeg-orig/libavfilter/Makefile ffmpeg/libavfilter/Makefile
--- ffmpeg-orig/libavfilter/Makefile	2020-05-23 19:20:02.000000000 +0300
+++ ffmpeg/libavfilter/Makefile	2020-05-31 08:40:48.813985000 +0300
@@ -28,8 +28,17 @@
 OBJS-$(CONFIG_QSVVPP)                        += qsvvpp.o
 OBJS-$(CONFIG_SCENE_SAD)                     += scene_sad.o
 include $(SRC_PATH)/libavfilter/dnn/Makefile
+include $(SRC_PATH)/libavfilter/hsv/Makefile
 
 # audio filters
+
+######################################
+# Additional filters:                #
+# "HSV" speech denoise filter.       #
+######################################
+
+OBJS-$(CONFIG_HSVDEN_FILTER)                 += af_hsvden.o
+
 OBJS-$(CONFIG_ABENCH_FILTER)                 += f_bench.o
 OBJS-$(CONFIG_ACOMPRESSOR_FILTER)            += af_sidechaincompress.o
 OBJS-$(CONFIG_ACONTRAST_FILTER)              += af_acontrast.o
@@ -436,7 +445,6 @@
 OBJS-$(CONFIG_UNSHARP_FILTER)                += vf_unsharp.o
 OBJS-$(CONFIG_UNSHARP_OPENCL_FILTER)         += vf_unsharp_opencl.o opencl.o \
                                                 opencl/unsharp.o
-OBJS-$(CONFIG_UNTILE_FILTER)                 += vf_untile.o
 OBJS-$(CONFIG_USPP_FILTER)                   += vf_uspp.o
 OBJS-$(CONFIG_V360_FILTER)                   += vf_v360.o
 OBJS-$(CONFIG_VAGUEDENOISER_FILTER)          += vf_vaguedenoiser.o
@@ -472,7 +480,6 @@
 OBJS-$(CONFIG_COLOR_FILTER)                  += vsrc_testsrc.o
 OBJS-$(CONFIG_COREIMAGESRC_FILTER)           += vf_coreimage.o
 OBJS-$(CONFIG_FREI0R_SRC_FILTER)             += vf_frei0r.o
-OBJS-$(CONFIG_GRADIENTS_FILTER)              += vsrc_gradients.o
 OBJS-$(CONFIG_HALDCLUTSRC_FILTER)            += vsrc_testsrc.o
 OBJS-$(CONFIG_LIFE_FILTER)                   += vsrc_life.o
 OBJS-$(CONFIG_MANDELBROT_FILTER)             += vsrc_mandelbrot.o
@@ -534,6 +541,7 @@
 
 clean::
 	$(RM) $(CLEANSUFFIXES:%=libavfilter/dnn/%)
+	$(RM) $(CLEANSUFFIXES:%=libavfilter/hsv/%)
 
 OPENCL = $(subst $(SRC_PATH)/,,$(wildcard $(SRC_PATH)/libavfilter/opencl/*.cl))
 .SECONDARY: $(OPENCL:.cl=.c)
